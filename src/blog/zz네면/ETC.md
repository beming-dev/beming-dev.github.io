Docker는 컨테이너 기반 가상화 방식으로, 호스트 커널을 공유하며 프로세스 수준으로 격리.
전통적인 VM과 달리, Guest OS 전체를 올리지 않고, 필요한 런타임/라이브러리만 독립된 컨테이너로 띄워서 훨씬 가볍고 빠른 실행/배포가 가능하다.

Call By Value: 함수를 호출할 때, 인수 복사본을 파라미터로 전달. 함수 내 변경이 원본에 영향 x
Call By Reference:  함수를 호출할때 인수의 주소를 넘김. 변경이 원본에 반영

- C, C++: 모두 Call By Value이나 포인터 써서 reference 가능
- Java: 모두 Call By Value이나, 객체 변수가 참조를 값으로 가지고 있음.
- Python: 공식적으로는 Call By Object Reference. 객체 참조가 복사되어 함수로 넘어감

모든 언어가 명확히 가지는것은 아님. Python, Java처럼 중간 형태를 갖는 언어도 있음.

# 순수함수, 함수형 프로그래밍

순수함수: 동일한 입력에 대해 항상 동일 결과를 반환. 외부상태를 변경하거나 의존하지 않음.
ex) f(x): x^2
함수형 프로그래밍 철학은 순수 함수를 많이 사용해서, 부작용을 최소화하고 프로그램의 예측 가능성과 안정성을 높이는 것이다.

## Side Effect
함수가 실행되면서 외부에 영향을 주거나, 외부 상태에 의해 결과가 달라지는 현상.
전역변수 변경, 파일 I/O, 네트워크 통신, 콘솔 출력 등

핵심 로직은 순수 함수로 작성하고, 부수적인 I/O나 전역상태 변화는 제한된 구역에서만 처리하자

1. 테스트, 디버깅 용이
2. 동시성에 유리
3. 가독성 향상

순수함수는 Thread Safe 하다. 
어떤 스레드가 언제 호출해도 외부 상태에 영향 없이 결과만 반환.

고차함수: 함수를 인자로 받거나, 함수를 반환하는 함수.
map, filter, reduce

# MVC 패턴
Model: 데이터와 로직.
View: 사용자 인터페이스, Model의 데이터를 화면에 렌더링
Controller: 사용자의 요청을 받고, Model과 View를 연결시킴

# 디자인 패턴
소프트웨어 설계 시, 반복적으로 나타나는 문제에 대해 재사용 가능한 해법을 정형화한 것.
생성패턴, 구조패턴, 행위패턴

Singleton에서 하나의 객체 생성 보장하는 방법
Private 생성자: 외부에서 new 불가능
static 메서드: 내부에서 인스턴스가 있는지 확인하고 없으면 생성
멀티 스레드 환경에서는 동기화 처리 필요.

# GC
동적으로 할당된 객체/메모리를 자동 해제하는 기법.

메모리 해제 실수를 방지
개발자 생산성 향상.

런타임 오버헤드
메모리 사용량 여유 있어야 함.

일반적으로 Heap영역의 동적 할당된 객체를 관리.
스택은 함수 호출 시점에서 자동 관리.

Reference Counting: 각 객체의 참조 카운트가 0이 되면 해제.
순환참조 발생 시, 참조 카운트가 0이 되지 않아 메모리 누수.

# 32bit vs 64bit

CPU/OS가 한번에 처리할 수 있는 레지스터 크기가 32냐 64냐.

메모리 주소를 표현할 수 있는 공간을 의미하기도 함.

32bit에서는 2^32 : 4GB까지 직접 주소화 가능
-> 가용 메모리가 4GB?


CPU가 직접 접근할 수 있는 메모리가 최대 4GB
Physical Address Extension기술.

# 인증과 인가의 차이
인증은 사용자가 누구인가를 식별.
인가는 접근 권한이 있는지 판단.

## OAuth란
3rd-party 애플리케이션이 사용자 리소스에 접근할 수 있도록 인가를 위임해주는 오픈 표준 프로토콜.

소셜 로그인에 이용되지만, 권한 위임 프레임워크

인증 기능도 구현 가능하지만, 기본 개념은 인가 로직

# JWT
JSON포맷의 Claim을 담아 서버가 클라이언트에 발행하는 토큰
Access Token으로 사용. HTTP Authorization 필드
Header, Payload, Signature로 구성

서버가 Header + Payload부분을 비밀키또는 비대칭키로 서명 생성
클라이언트는 토큰 전체 보관했다가 요청 시 전송. 서버는 다시 서명을 검증해 토큰 무결성 체크.

Access Token이 탈취된 경우 대응.
Access Token이 유효기간 내에 탈취되면, 공격자가 해당 토큰으로 리소스 접근 가능.
- 토큰 강제 무효화
- Refresh Token으로 재발급 시도 시 이상 감지.
- 만료시간이 짧은 Access Token 사용.


# 암호화 알고리즘
대칭키 암호: 하나의 키로 암호화, 복호화 둘 다 수행 간단하지만 키 공유 문제

비대칭키 암호: 공개키로 암호화, 개인키로 복호화. 키 공유 문제 해결

해시 함수:입력 데이터를 고정 길이 해시값으로 매핑. 복호화 불가, 무결성 검증, 서명 등에 사용.

비대칭키로 세션키 교환하고, 이후에는 대칭키로 빠르게 암호화 가능.

# 문자열 인코딩
텍스트를 어떤 규칙에 따라 바이트 시퀀스로 변환하는 것.

Base64 인코딩: 바이너리 데이터를 ASCII 범위 문자로 안전하게 변환.
이진 파일을 텍스트 프로토콜에 삽입할 때 깨짐 없이 전송

ASCII에 제어문자가 있어서 64개가 가장 크게 ASCII로 표현 가능

# GIT
분산 버전 관리 시스템.
로컬 저장소, 원격 저장소 구분.
변경 이력을 관리하고, 브랜치로 분기해서 개발 후 통합.

## 브랜치 합치기

Merge: 한 브랜치가 다른 브랜치의 끝을 이어받아 히스토리를 직선으로 합침.

rebase: 한 브랜치의 커밋들을 다른 브랜치 위로 차례대로 재적용. 히스토리 깔끔해지지만 force push 필요해질수도 있음.

squash and merge; 여러 커밋을 하나로 합쳐서 Merge

Cherry-pick: 특정 커밋만 골라서 다른 브랜치에 적용.
모든 커밋을 합치는게 아니라, 필요한 부분만 가져올 때

# OAuth

Resource Owner: 사용자
Client: 자원 소유자의 데이터에 접근하려는 3자 애플리케이션
Authorization Server: 자원 소유자를 대신해 권한 부여를 담장하는 서버
Resource Server: 실제 자원을 호스팅하는 서버.

- 클라이언트 -> 사용자 OAuth 서버로 이동할 수 있는 URL 제공
- 클라이언트 -> 인가 서버 브라우저 리다이렉트로 보냄. client_id, redirect_uri, scope 등 포함
- 사용자 인증, 동의: 인가 서버가 먼저 로그인 했는지 확인. 안됐으면 로그인 시키고, scope 동의 물어봄.
- 사용자가 동의하면 인가서버가 Authorization Code 발급
- 클라이언트는 전달받은 인가 코드와 함께 client_id, client_secret 등 정보를 Authorization server에게 요청 -> AccessToken, Refresh Token받음.
- 클라이언트가 Access Token으로 Resource Server에 API 요청

# JWT
1. JSON 형태의 데이터를 담은 토큰. Header, Payload, Signature로 구성

Header: 어떤 알고리즘으로 서명을 생성했는지.
Payload: 실제 인증/인가 정보가 JSON 형태로 포함.
Signature: Header + Payload기반으로 비밀키로 생성한 서명. 토큰이 변조되지 않았음 보장.

Header와 Payload는 JSON -> base64url로 인코딩, Signature도 마찬가지
토큰 내부에 식별 정보, 만료시간, 권한 범위 등 담을 수 있음.

1. 사용자 로그인. 성공하면 JWT의 payload를 구성
2. 서명 생성 & 토큰 발급 -> 클라이언트에 전달
3. 클라이언트가 Http 쿠키나 Localstorage에 저장.
4. 서버는 토큰의 Signature 검증. 유효하면 Payload 디코딩해서 정보 확인.
토큰 무효화, 블랙리스트를 위해 토큰이 유효한지를 DB에 저장해 확인할 수 있음.

서버 부담 없이 여러대로 확장 가능.
요청마다 정보가 토큰에 담김
클라이언트 분산.

토큰 탈취 위험.
Payload 커질 수 있음.
즉각적 로그아웃/권한 철회가 어려움.

## Refresh token
AccessToken보내다가 만료 시 RefreshToken을 전송. 서버가 유효한지 확인 후 새로운 Access Token발급함.

# 쿠키
XSS로 인해 쿠키 탈취당할 수 있다. 쿠키에 HttpOnly 속성 부여하면, JS에서 읽을 수 없다.

Cross-Site Request Forgery: 악성 사이트, 스크립트가 사용자 브라우저를 통해 쿠키를 포함한 요청을 보냄.
- SameSite 쿠키 속성으로 타 도메인에서 쿠키 전송 막기
- CORS 정책

HTTP로 전송되면 탈취 가능

기존 세션ID를 공격자가 미리 알아낸 후, 사용자가 그 세션 ID로 로그인하도록 유도 -> 공격자가 동일 세션 ID로 접근 가능.

로그인 시 새로운 세션 ID 재발급. 쿠키 재설정

LocalStorage는 XSS에 취약.

쿠키를 사용하되, 여러 설정 적절히 설정.