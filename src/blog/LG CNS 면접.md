**■ 우리는 이런 일을 해요!**

- 클라우드 아키텍트는 기업의 클라우드 인프라를 설계하고 최적화하여 비즈니스 요구에 맞는 효율적이고 안전한 클라우드 환경을 구축하는 역할을 담당합니다.

- 최신 클라우드/인프라 기술을 활용하여 고객의 요구에 부합하는 Private, Public, 및 Hybrid Cloud 솔루션을 설계하고, 클라우드 전환 및 통합 프로젝트를 성공적으로 이끌어갑니다.  
- 고객의 비즈니스 목표와 IT 전략에 맞춰 최적의 클라우드 아키텍처를 제안하며, 고가용성과 확장성을 갖춘 클라우드 인프라를 구축하여 안정적이고 효율적인 운영을 지원합니다.

- Public Cloud, Muliti Cloud, Hybrid Cloud, 5G 특화망, AI인프라(HPC) 등 혁신적인 인프라 솔루션을 통해 인프라의 미래를 선도하고 이끌어갑니다. 

**■ 역량 있는 여러분의 지원을 기다립니다.**  
- 클라우드 및 인프라 아키텍처에 대한 깊은 관심을 가지고, 시스템, 네트워크, 데이터베이스 등 클라우드 및 인프라 아키텍처에 대한 폭넓은 이해와 열정을 가진 분

- 새로운 기술과 환경에 대한 변화를 적극적으로 수용하며, 이를 즐기고 도전하는 자세를 가진 분

- 문제 발생 시, 스스로 해결책을 모색하고 문제를 해결하는 것을 선호하는 분

- 세부 사항에 집중하기보다는 전체적인 시각을 가지고 문제를 파악하고 해결하며, 원활한 소통을 통해 협력하는 능력을 가진 분

- 다양한 부서와의 적극적인 소통을 통해 문제를 정확히 파악하고 효과적으로 해결하려는 자세를 가진 분

- 최신 기술에 대한 높은 관심과 지속적인 학습 의지를 가진 분

- Data Architecture, Infra Architecture, Application Architecture, Cloud Architecture 직무를 희망하는 분


- **최적의 시스템 구조 설계:** 고객의 비즈니스 요구사항을 파악하고, **'비기능적 요구사항'(성능, 안정성, 확장성, 보안 등)**을 고려하여 시스템의 전체적인 구조(예: MSA, Cloud-Native)를 설계합니다.
    
- **기술 표준 및 원칙 수립:** 프로젝트에서 사용할 기술 스택(언어, 프레임워크, DB 등)을 선정하고, 개발자들이 따라야 할 설계 원칙과 코딩 표준, 개발 프로세스를 수립합니다.
    
- **개발자 리딩 및 기술 자문:** 개발자들에게 설계를 공유하고, 개발 과정에서 발생하는 복잡한 기술적 문제를 해결해 주며, 코드 리뷰 등을 통해 품질을 관리합니다. 즉, 프로젝트의 **'기술 리더'** 역할을 수행합니다.
    
- **성능 최적화 및 장애 해결:** 시스템 오픈 전/후에 발생할 수 있는 성능 병목 현상을 분석하고 최적화하며, 장애 발생 시 원인을 파악하고 해결하는 **'시스템 닥터'** 역할을 합니다.
    
- **신기술 PoC 및 도입:** AI, Big Data, Cloud 신기술 등을 사전에 검토하고 PoC(Proof of Concept, 개념 검증)를 수행하여, 실제 프로젝트에 안전하게 도입할 수 있도록 가이드합니다.

# 클라우드 (AWS)에 대한 기본 이해

EC2: 클라우드 환경에서 가상 인스턴스를 대여해서 사용할 수 있는 서비스 입니다. CPU, 메모리 등 필요한 사양을 선택해서 사용하고, 사용한 만큼의 비용을 지불합니다.

S3: 인터넷용 파일 창고입니다. 각종 파일을 저장하고 관리하는 데에 특화된 서비스입니다.

RDS: 클라우드 기반의 관계형 DB입니다. MySQL, PostgreSQL, Oracle 등 익숙한 DB를 AWS가 대신 설치해주고 운영/관리를 자동화해주는 서비스입니다.

VPC: AWS 클라우드 내의 가상 사설 네트워크입니다. 계장마다 독립된 가상 네트워크 공간을 만들어, 그 안에 EC2, RDS같은 자원들을 배치하고 격리해줍니다. 

ELB: Elastic Load Balancing. 요청을 여러 대의 EC2 서버로 자동으로 나누어 보내는 역할을 한다.

ASG: Auto Scaling Group. 트래픽 양에 따라 EC2 서버의 수를 자동으로 늘리거나 줄여줍니다. 

IAM: AWS 모든 서비스에 대해 누가 무엇을 어떻게 할 수 있는지 정의. 세밀한 권한 제어

ECS: Docker 컨테이너 관리도구
EKS: AWS환경에서 Kubernetes를 쉽게 설치하고 운영

CloudWatch: 통합 모니터링 및 로깅. EC2의 CPU 사용률, RDS의 DB 연결 수, ELB로 들어오는 트래픽 양 등 AWS 자원의 모든 상태를 감시하고 로그를 수집.

# MSA 

 모놀리식 과의 차이점: 배포 단위에 차이가 있습니다. 회원 관리, 상품 관리 등 모든 기능이 하나의 애플리케이션에 묶여 잇습니다. 반면 MSA는 여러 서비스를 각각 독립된 작은 애플리케이션으로 분리하여 개발, 배포합니다.
 
 
 MSA의 장단점 (왜 사용하냐): 각 서비스는 독립적으로 개발, 배포, 확장이 가능하고 장애 격리가 가증하다는 장점이 있습니다. 하지만 관리 복잡성이 증가합니다. 서비스간 통신이 필요하므로 네트워크 통신 오버헤드가 발생합니다. 서비스별로 DB를 분리한다면 트랜잭션을 관리하기가 매우 어렵습니다.
 서비스가 거대해지면 빠른 변화와 확장의 한계를 극복하기 위해 운영 복잡성을 감수하면서 도입. 보통 조직의 구조를 따라가는 경우가 많음.

MSA를 구성하는 패턴(API Gateway, Service Discovery 등)
1. API GateWay:  외부에서 들어오는 모든 요청을 가장 앞에서 받아 각 마이크로서비스로 연결해주는 단일 진입점.
2. Service Discovery: Auto Scaling 등으로 IP 주소가 계속 변하는 마이크로서비스들의 현재 위치를 등록하고 찾아주는 동적 주소 (Eureka, Consul, Kubernetes 내부의 DNS)
3. 회로 차단기: 특정 서비스에 장애가 발생하여 느려지면, 해당 서비스로의 요청을 일시적으로 차단하여 장애가 다른 서비스로 전파되는것을 막는 패턴

# 컨테이너

**Docker:** 컨테이너가 무엇인지, 가상머신(VM)과 어떻게 다른지 알아야 합니다.

컨테이너란 실행 가능한 소프트웨어 패키지입니다. 코드와 코드 실행에 필요한 모든 설정을 포함합니다. Docker는 이러한 컨테이너를 만들고 관리하고 실행하는 플랫폼입니다. 가상머신은 하드웨어 위에 하이퍼바이저를 설치하고, 그 위에 Guest OS를 통째로 설치합니다. 그래서 매우 무겁습니다. 반면에 컨테이너는 Host OS 위에 설치되며, Host OS의 커널을 공유합니다. 매우 가벼워서 효율이 좋습니다.

**Kubernetes (K8s):** '왜' K8s가 필요한지(컨테이너 오케스트레이션), 주요 구성 요소(Pod, Service, Deployment 등)는 무엇인지 준비해야 합니다.

Docker는 단일 서버에서 컨테이너를 몇개 실행할때는 훌륭합니다. 하지만 실제 대규모 서비스 환경에서 수천 수백개의 컨테이너를 운영하려면 여러 서버에서 동시에 돌아가야 합니다.

이 때, 이 컨테이너들을 어떤 서버에 배치할지, 서버 한대가 다운되면 컨테이너들을 어떻게 할지, 트래픽이 몰릴때 어떻게 관리할지, 업데이트를 중단없이 어떻게 할지, 이 모든 문제를 해결해주는 컨테이너 오케스트레이션 툴로 Kubernetes를 사용합니다.

# 데이터베이스

ACID
A(Atomicity):원자성. 트랜잭션은 전부 성공 아니면 전부 실패해야 합니다.
C(Consistency):일관성. 트랜잭션은 성공적으로 완료되면, 데이터베이스는 항상 일관된 상태를 유지해야합니다.
I(Isolation): 격리성. 여러 트랜잭션이 동시에 실행될 때, 서로 영향을 주지 않고 혼자 실행되는 것처럼 보여야 합니다.
D(Durability): 지속성. 성공적으로 Commit된 트랜잭션의 결과는 시스템에 장애가 발생하더라도 영구적으로 저장돼야함.


**RDBMS (SQL):** 트랜잭션(Transaction), 정규화(Normalization), 인덱스(Index)의 원리와 중요성을 이해해야 합니다.

트랜잭션은 쪼갤 수 없는 논리적인 작업 단위. 데이터의 일관성과 신뢰도가 필요한 작업에 필수적.

정규화: 데이터의 중복을 최소화 하고, 무결성을 높이기 위해 테이블을 구조화. 테이블을 분리. 너무 쪼개면 데이터를 조회할 때 여러 테이블을 JOIN 해야 하므로 쿼리 속도가 느려질 수 있다.

인덱스: 데이터베이스의 검색 속도를 높이는 기술. SELECT쿼리의 속도를 증가시키지만, Insert, Update, Delete 작업의 속도는 느려짐. 데이터의 위치를 따로 색인으로 저장

**NoSQL:** RDBMS와의 차이점, NoSQL이 필요한 시나리오(예: 대용량 로그 데이터, 비정형 데이터 처리)를 아는 것이 좋습니다.

유연한 스키마 -> 데이터마다 구조 달라도 됨. 수평 확장. 신뢰도보다 속도/가용성 유선. Key-Value, Document, Graph등 다양

RDBMS의 엄격한 시키마와 수직 확장성의 한계를 극복할 때 사용합니다. 
쓰기 작업이 매우 빈번하고 양이 많을 때.
데이터의 구조가 자주 변경될 때
서비스의 폭발적 성장

RDBMS는 수평적 확장을 하게 되면 일관성 유지가 어려움. 여러 서버의 테이블에서 트랜잭션이 발생하면, 두 서버 모두 성공하거나 실패해야함. -> 분산 트랜잭션 기술이 필요. 서버가 많아질수록 기다리는 시간이 기하급수적으로 늘어남. 또한 JOIN의 성능이 엄청 나빠짐

인덱스와 B-Tree: B-Tree: 루트에서 리프까지 깊이 항상 일정하게 유지. 높이가 곧 성능. 

# AI 아키텍처

**RAG (Retrieval-Augmented Generation):** LLM이 외부 지식을 활용하게 하는 RAG의 기본 개념.

LLM에게 오픈북하게 하는 기술. 검색과 생성을 결합함. 사용자의 질문을 받으면 우리의 외부 데이터베이스를 검색. 찾아낸 관련 문서를 원본 질문에 덧붙혀서 프롬프트 전달. 답변 생성. 할루시네이션 줄임

**AI 학습/추론 환경:** MLOps의 개념, 즉 AI 모델을 개발하고 배포/운영(학습 및 추론)하는 환경을 어떻게 구축할지에 대한 고민이 필요합니다.

AI 모델을 만드는 공장을 짓고 운영하는 모든 활동. 모든 생명주기를 관리.
데이터 관리. 모델 개발 및 학습. 모델 배포. 모델 모니터링 및 재학습.

# 프로젝트

프로젝트에서 Spring Boot를 사용하셨네요. **왜** Node.js가 아니라 Spring Boot를 선택했나요?" 
Spring boot는 정적타입언어로, 컴파일 시점에 오류를 잡을 수 있어 안정성이 높고, Spring JPA와 같은 강력한 도구로 DB 트랜잭션을 관리하기가 쉬웠습니다. 또한 Spring Security등 보안 및 인증 기능이 잘 통합되어 있어 선택했습니다.

프로젝트에서 Node.js를 사용하셨네요. **왜** Spring Boot 가 아니라 Node.js를 선택했나요?"
저희 프로젝트는 채팅 기능, 대량의 API 요청을 동시에 처리하는 I/O바운드 작업이 핵심이었습니다. Node.js의 이벤트 기반 비동기 모델은 단일 스레드로도 높은 동시성을 처리할 수 있어, Spring보다 적은 서버 자원으로 동시에 더 많은 연결을 처리할 수 있다고 생각했습니다. 

프론트엔드 코드가 TypeScript를 사용하고 있었습니다. 초기에는 NExt.js의 Api라우터를 사용했는데, 이 코드 베이스를 옮기려다 보니까 Node.js 생태계가 더 편리했습니다. 또한 구성원들이 사용하는 기술 스택도 Javascript쪽이었기 때문에, 이러한 점들을 고려해서 Node.js를 기술 스택으로 선정했습니다.

"데이터베이스로 MySQL을 사용했는데, **왜** MongoDB 같은 NoSQL을 고려하지 않았나요?"

"네, 저희 프로젝트는 **데이터의 구조가 명확하게 정형화되어 있지 않았고, 기획에 따라 요구사항이 자주 변경**되었습니다.

예를 들어, 저희는 '사용자 활동 로그'나 '상품의 다양한 옵션'을 저장해야 했습니다. 만약 MySQL 같은 RDBMS를 사용했다면,

1. 로그의 종류가 추가되거나 상품 옵션이 바뀔 때마다 매번 `ALTER TABLE`을 통해 **테이블 스키마(구조)를 변경**해야 했습니다. 이는 운영 중인 서비스에서는 매우 부담스럽고 위험한 작업입니다.
    
2. 또한, 데이터마다 필드가 달라서(비정형 데이터) `NULL` 값이 많은 비효율적인 테이블이 만들어질 수 있었습니다.


프로젝트 중 겪었던 가장 어려웠던 **기술적 문제**

"만약 이 서비스의 사용자가 100만 명으로 늘어난다면, 아키텍처를 어떻게 변경하시겠어요?" (확장성)

수평적 확장 전략이 필요하다고 생각합니다. 현재의 코드는 모놀리팅 구조를 갖추고 있습니다. ELB와 ASG를 사용해서 트래픽에 따라 인스턴스 수를 자동으로 늘리면 좋을것 같습니다. 추가로 MSA를 적용한다면 이러한 이점을 더 크게 볼 수 있을것 같습니다.
또한 DB 병목이 발생할텐데, MySQL의 Read Replica를 구성하여, 쓰기는 MasterDB, 읽기는 ReplicaDB로 분산할 수 있을 것입니다. 또한 캐싱을 사용하여 DB접근도 줄이겠습니다.

자신이 진행한 프로젝트를 **성능, 확장성, 보안, 안정성**의 관점에서 다시 한번 복기해 보세요.

# 인터넷

서울에서 일 할 수 있나?  

하고싶은 직무가 있나?  

힘들었던 프로젝트는?

보안정책, 그리고 보안운영의 중요성에 대해서 말해보아라  

ERP , MES시스템에 대해서 알고 있는지  

서버 장애 발생시 문제 역추적을 하는데 있어 어떤 점을 고려하고, 우선순위는 어떻게 해야하는지

이 직무를 선택한 이유와 관련된 경험.  

이 부서가 하는일이 무엇인지 아는지, 그리고 온다면 무슨 역할을 하게 될지  

리더쉽에 관한 경험이 있는지.

laas paas saas 에 대해서

DX의 의미

LG CNS를 지원한 이유  

다른 회사에 합격해도 LG CNS를 올것인지?

클라우드 아키텍트로 지원 동기와 어떤 아키텍트로 성장 하고 싶은지
클라우드 환경에서의 설계를 하고 싶어서 지원했다고 답변했고, 면접관님께서 아키텍트 세부 R&R 대해 좀 더 자세히 설명해 주셔서 인상이 깊었던거 같습니다

3사 SI회사 중 왜 LG CNS에 지원했는가?를 물어보셨습니다

개발 말고 장단점은 무엇인가?  

왜 우리회사에 지원했나?  

멀티 클라우드로 시스템을 구축할 때 어떤 점을 주의해야 하는지 설명해보라

그레이존이 생길 경우 어떻게 하는지?  

개발자와 이슈가 생겼을 때 해결 경험  

K8S 네트워크 관련 질문

2지망으로 클라우드 분야를 선택하셨는데 정말 관심이 있어서 선택한 것인지?  

글로벌 역량을 위해 노력한 경험  

동아리 활동에서의 프로젝트는 기업과 연계해서 진행한 프로젝트인지?

SW개발에 대한 관심도를 묻는 질문

학교에서 가장 어려웠던 프로젝트

B2C와 B2B의 차이점이 무엇인지, LG CNS를 지원한 이유는 무엇인지 엮어서 설명해라.  

코볼과 같은 옛날 기술 개발을 5년동안 맡는다고 하면 어떻게 할건지?  

도메인 전문가가 있고, IT 전문가가 있는데 어떤 전문가로 성장하고 싶은지?

왜 IT서비스 기업이 아닌 LG CNS인지를 잘 준비해가면 좋을 것 같습니다.

# 1분 자기소개

안녕하세요 LG CNS architecture 직무에 지원하게 된 채민관입니다!

개발자로서 저는, '안정적인 서비스 운영'과 '사용자 요구사항에 기반한 혁신'이라는 두가지 가치를 가장 중요하게 생각합니다. LG CNS 직무는 고객사의 요구사항을 바탕으로, 안정적인 서비스를 설계하는 직무이므로, 이러한 가치를 실현할 수 있는 곳이라 생각하여 지원하였습니다.

저는 다양한 프로젝트들을 운영해보며 개발 역량을 쌓아왔습니다. 특히, 그 중에서도 수 년간 수 백명의 유저가 사용하는 대학생 모임 플랫폼을 운영하며 개발역량과 아키텍처 역량을 길러왔습니다. AWS 클라우드 상에서 인스턴스에 Docker로 서비스를 배포하고, CodePipeline을 사용한 CI/CD 파이프라인을 구성해본 경험과 ELK 스택을 도입하여 실시간으로 에러를 모니터링할 수 있는 구조를 갖춘 경험 등이 그러합니다. 

제가 쌓아온 설계, 운영, 학습 역량을 바탕으로, 고객의 비즈니스 요구에 맞는 **최적의 클라우드 아키텍처를 설계**하는 전문가로 LG CNS와 함께 성장하겠습니다.


# 자기소개서 1번
LG CNS에 지원한 동기와 입사 이후 꿈꾸는 것은 무엇인가요? (500자)

## "본인이 개발자로서 '안정과 혁신'이라는 두 가지 가치를 추구한다고 하셨습니다. 하지만 아시다시피 **안정성을 추구하면(예: 검증된 기술 사용) 혁신이 더뎌질 수 있고, 혁신을 추구하면(예: 신기술 도입) 안정성이 떨어질 수 있습니다.** 이 두 가치가 상충될 때, 본인은 어떤 기준으로 우선순위를 판단하며, 이를 조율해 본 경험이 있나요?"

네 제가 스타트업에서 인턴으로 일을할 때, 업무의 일정이 상당히 빡빡했었습니다. 코드의 구조를 설계하면서 서비스를 개발하는 것이 쉽지 않은 상황이었습니다. 저는 이럴때 요구사항에 맞게 하면 된다고 생각합니다. 개발 속도가 중요한 상황이라면 빠르게 개발 하는것에 우선을 두고, 기간이 넉넉하고 안정성이 중요한 금융과 같은 서비스라면 안정성을 최우선으로 해야합니다. 저의 경우에는 최대한 빠르게 개발을 마쳐두고, QA가 진행되는 기간동안 코드를 리팩토링하거나 하는 식으로 빠른 속도를 먼저 추구하고 나중에 안정성을 추구하는 방식을 택했었습니다. 

## "LG CNS가 '안정'과 '혁신'을 모두 갖췄다고 하셨는데, 그렇게 생각하게 된 구체적인 사례나 프로젝트가 있다면 말씀해 주세요."

먼저, 안정성은 수십년간 국내 IT 핵심 산업의 IT 시스템을 구축하고 운영해 온 '신뢰'에서 온다고 생각합니다. 국내 금융권의 시스템을 설계하고, 특히 코로나 19 백신 예약 시스템에 장애가 발생했을 때, LG CNS의 아키텍트 분들이 시스템 닥터로 투입되어 문제를 해결한 사례는, '국가적 IT 위기'를 해결할 만큼의 기술적 노하우로 안정성을 갖췄다고 생각합니다. 

또한 혁신은 이러한 안정성 위에서 클라우드 네이티브와 AI로 성공적으로 전환시키는 기술력에 있다고 생각합니다. 단순히 클라우드 재판매가 아닌, DAP GenAI와 같은 자체 생성형 AI 플랫폼을 출시하고, AM 사업을 통해 고객사의 레거시 시스템을 전환해주는 등 혁신성은 LG CNS 하면 빼놓을 수 없는 부분이라고 생각합니다.

## '안정적인 시스템'을 구축하기 위해 아키텍트로서 가장 중요하게 고려해야 할 점이 무엇이라고 생각하나요?"

먼저 사전에 장애를 예측하거나 예방할 수 있는 시스템을 갖춰야 합니다.
그리고 이러한 시스템을 갖춰도, 언제든 장애는 발생할 수 있다는 생각으로 회복 탄력성을 갖춰야 합니다.
특히 현대의 클라우드와 MSA 환경은 수많은 컴포넌트가 얽혀있어, 장애를 피하기 어렵습니다.
그래서 다음과 같은 세가지를 고려해야 합니다.
1. 장애가 발생했을 때, 그 영향 범위를 최소화 하도록 격리해야 합니다. 요청을 비동기 처리하는 메시지큐
2. 어떤 컴포넌트가 실패해도, 즉시 대체할 수 있는 예비 컴포넌트가 있어야 합니다. 로드 밸런서 뒤에 여러 대의 EC2 서버를 두거나 kubernetes를 사용하면 될 것 같습니다.
3. 그리고 에러를 즉시 감지할 수 있어야 합니다. 여러 지표들과 로그 데이터를 수집하고 모니터링 가능한 환경을 구축해야 합니다. 

## "자소서에 '기존 시스템을 MSA 기반 클라우드 네이티브로 전환하는 프로젝트'에 기여하고 싶다고 하셨습니다. **모든 시스템을 MSA로 전환하는 것이 항상 정답은 아닐 텐데요.** 어떤 특징을 가진 시스템이 MSA 전환에 적합하다고 생각하며, 반대로 모놀리식(Monolithic) 아키텍처가 더 유리한 경우는 어떨 때라고 생각하시나요?"

시스템의 구조는 조직의 의사소통 구조를 따라야 한다고 생각합니다. 개발팀의 규모가 크지 않고, 개발 파트가 크게 분리돼있지 않다면, 모놀리틱 구조를 사용하는게 좋을 것입니다. MSA로 전환했을 때, 컴포넌트간 통신 등 생기는 오버헤드 관리가 더 트레이드 오프 측면에서 좋지 않을것 같습니다.
반면 조직이 크고, 개발팀에서 맞는 업무가 분리되어 있어 이들간의 작업이 자주 겹칠 수 있다면, MSA구조를 도입하는 것이 좋을것 같습니다. 
트래픽을 기준으로 생각해볼 수도 있을 것 같습니다. 모놀리틱 구조는 트래픽이 많아져 시스템을 확장할 때, 전체 시스템을 복제해야 해서 리소스를 많이 사용합니다. 반면, MSA 구조에서는 필요한 컴포넌트만 확장할 수 있으므로 리소스 효율이 좋을 것입니다.

## "기존의 오래된 시스템(Legacy System)을 MSA로 성공적으로 전환하기 위해 **아키텍트가 가장 먼저 분석해야 할 것은 무엇**이라고 생각하며, **가장 큰 기술적 난관(Hurdle)은 무엇**일 것 같습니까?"

가장 먼저, 비즈니스 도메인을 파악하는 것이 중요하다고 생각합니다. 레거시 시스템의 코드는 스파게티 처럼 얽혀 있을 것입니다. MSA의 핵심은 서비스를 '비즈니스 기능' 단위로 분리하는 것입니다. 도메인 주도 개발의 바운디드 컨텍스트 개념을 활용하여, 각 도메인을 정의하고 도메인 단위로 서비스를 분리할 것 같습니다.(같은 단어가 문맥에 따라 다른 의미로 사용될 수 있음. 컨텍스트를 분리하여 이를 방지) 

가장 큰 기술적 난관은, 데이터 일관성 문제일 것이라 생각합니다.
레거시 시스템은 대부분 하나의 DB를 사용합니다. 덕분에 데이터 일관성을 쉽게 보장합니다. 하지만 MSA에서는, 각 서비스가 자신만의 DB를 소유하는 것이 원칙입니다. 이로 인해, 여러 요청을 하나의 트랜잭션으로 묶을 수 없습니다. 그래서 '최종 일관성' 개념을 도입해 합니다. 주민이 성공하면 결제를 호출하고, 결제가 실패하면 주문에 대한 보상 트랜잭션을 실행하는 방식으로, 데이터의 일관성을 맞춰야 합니다.

이 전환을 어떻게 하시겠어요?
시스템 전체를 한번에 바꾸지 않고, 기존의 시스템을 그대로 두고, API 게이트웨이를 통해 새로운 상품 기능 요청만 신규 MSA로 라우팅하는 식으로 점진적이고 안정적이게 교체할 것입니다.

## "클라우드 네이티브 애플리케이션'이라고 하셨는데, 본인이 생각하는 '클라우드 네이티브'의 핵심 요소는 무엇인가요?" (12-Factor App, 컨테이너, K8s, DevOps 등)

클라우드 네이티브는 애플리케이션을 클라우드에서 실행하는 것을 넘어, 탄력성, 확장성, 회복탄력성을 최대한 활용하도록 설계된 애플리케이션과 문화를 의미합니다. 

컨테이너: 애플리케이션과 실행에 필요한 모든 환경을 함께 묶는 것입니다. 실행환경마다 다르게 실행되는 것을 맏아줍니다.

MSA: 거대한 애플리케이션을 독립적인 비즈니스 기능 단위로 잘게 쪼갠 아키텍처입니다.

컨테이너 오케스트레이션: 여러 마이크로서비스 컨테이너를 자동으로 관리하는 기술입니다. kubernetes와 같은 것을 사용하며, 트래픽이 몰리면 자동으로 확장하고, 장애가 난 컨테이너를 자동으로 복구하며, 무중단 배포를 가능하게 합니다. 

## "설계 시 '보안, 성능, 운영 효율성' 등 다양한 비기능적 요구사항을 고려한다고 하셨습니다. 만약, **'빠른 개발 속도(성능/효율성)'**와 **'강화된 보안'**이라는 두 가지 요구사항이 충돌한다면, 아키텍트로서 어떤 선택을 하실 것이며 그 이유는 무엇인가요?"

## "본인이 참여했던 프로젝트에서 **'성능'**을 개선하기 위해 아키텍처 관점에서 고민하고 적용해 본 사례가 있다면 말씀해 주세요." (예: 캐시 도입, DB 인덱싱, 비동기 처리 등)

제가 서비스를 운영하던 중, API의 응답 속도가 느려지면서, 서비스의 초기 페이지 렌더링이 느려지는 문제가 있었습니다. 당시 ELK 스택을 도입한 직후였는데, 가장 먼저 느려진 API를 찾기 위해 모든 API 요청의 응답속도를 로깅하고, kibana dashboard에서 분석하였습니다. 그 결과, 느려진 API를 찾을 수 있었고 DB 쿼리가 복잡하고, 너무 큰 용량의 데이터를 검색해서 보내다보니, 네트워크가 병목되고 있다는 것을 파악했습니다. 그래서 당시 제가 공부하고 있던 Redis를 사용하여 데이터를 캐싱하기로 했습니다. 처음에 Redis에 캐싱을 했는데, API 응답속도가 빨라지지 않았습니다. 데이터 자체 크기가 너무 큰 것이 원인이라 생각했고, 데이터를 압축하여 Redis에 캐싱하니 평균 응답속도가 300ms 대에서, 100ms 아래로 70퍼센트 이상 감소했습니다.

## '운영 효율성'을 높이는 아키텍처는 구체적으로 어떤 모습일까요?" (예: CI/CD 파이프라인, 모니터링/로깅(MSA) 등)

먼저 아키텍처 적으로는, 개발자가 코드에만 집중할 수 있는 환경이 만들어져야 합니다. 로깅, 모니터링 시스템이 안정적으로 구축되어 있고, CI/CD 파이프라인이 잘 설계돼있다면 가능하다고 생각합니다. 또한 MSA 구조가 잘 도입되어야 하는데, 이러기 위해서는 코드의 구조 또한 안정적이어야 합니다. 도메인 단위로 시스템이 잘 분리돼있고, 의존성 역전 개념을 잘 적용해, 핵심 비즈니스 로직이 외부 라이브러리나 DB에 의존하지 않는 구조가 설계되어 있어야 효율적인 운영이 가능하다고 생각합니다. 

**자동 복구 및 확장 (Self-Healing & Auto-Scaling):** Kubernetes(K8s)가 장애 난 Pod를 자동으로 재시작하거나, **ASG(Auto Scaling Group)**가 트래픽에 따라 EC2 인스턴스 수를 자동으로 늘리고 줄이는 모습입니다.

## "궁극적으로 '대규모 트래픽을 다루는 시스템'을 설계하고 싶다고 하셨습니다. 현재 수준의 트래픽을 처리하는 시스템과 대규모 트래픽을 처리하는 시스템의 **아키텍처는 근본적으로 무엇이 달라야 할까요?**" (이 질문은 이전 대화에서 다룬 Scale-out, DB 확장, 캐시, MQ 등을 답변할 기회입니다.)

트래픽이 많지 않다면, 트래픽이 조금 증가해도, CPU나 메모리를 업그레이드 하는 방식으로 해결할 수 있습니다. 하지만, 대규모 트래픽이라면 인스턴스를 늘리거나 여러대의 서버로 확장(수평적 확장)할 수 있어야 합니다.

먼저 서버가 상태를 가지면 안됩니다. 사용자가 1번 서버로 로그인 할 때와, 3번 서버로 로그인 할 때의 결과가 같아야 합니다. DB 병목을 감당해야 합니다. DB 접근 자체를 최소화하고, 요청의 대부분을 차지하는Read와 같은 것들은 Read Replica Set 같은 것을 구성하여, 쓰기는 MAsterDB, 조회는 ReplicaDB가 처리하는 구조를 갖추면 좋습니다.
모든 요청을 실시간 동기로 처리할 수는 없습니다. 요청을 비동기적으로 처리할 수 있어야 합니다. '주문' 요청을 받았을 때, 사용자에게 성공 요청을 보내고, 그 외 작업은 메시지 큐에 넣어둡니다. 그리고 분산된 서버들이 이를 가져와 처리하면 응답 속도를 높이고 부하도 분산할 수 있습니다.

## "말씀하신 '비즈니스 변화에 민첩하게 대응할 수 있는 아키텍처'란 구체적으로 어떤 아키텍처를 의미하는지 설명해 주실 수 있나요?" (MSA의 장점과 연결)

제가 생각하는 비즈니스 변화에 민첩하게 대응하는 아키텍처란, 수정 작업에서 미치는 영향을 최소화하고, 배포의 안정성을 극대화한 아키텍처입니다. 
서비스가 도메인으로 분리되어 있지 않거나, 외부 코드에 의존성이 강하게 있다면, 작은 비즈니스 로직의 수정으로도, 전체 시스템을 다시 테스트하고 배포해야 할 수 있습니다. 반면 MSA를 도입한다면, 각각이 독립적인 서비스로 분리되어 있어 수정의 영향을 최소화할 수 있습니다. 또한 의존성 역전과 같은 개념을 사용하여, 추상화된 모듈에 의존한다면, 외부의 수정이나 변경에 핵심 비즈니스 로직을 변경해야 하는 일이 줄어들 것입니다.


# 자기소개서 2번
지원 분야와 관련된 구체적인 지식이나 경험을 기술해 주십시오. (1000자)
## "클린 아키텍처를 적용해 비즈니스 로직과 인프라를 분리했다고 하셨습니다. 본인의 프로젝트에서 **가장 핵심적인 비즈니스 로직(도메인)**은 무엇이었나요? 그리고 그 로직을 **DB(JPA Entity)의 의존성으로부터 분리하기 위해** 실제 코드는 어떻게 구성하셨는지(예: Usecase, Repository Interface) 설명해 주세요."

저희 서비스는 대학생 스터디 동아리에서 시작했습니다. 그래서 가장 중요하게 생각한 부분은 스터디 도메인 이었습니다. 사용자가 스터디에 신청할 때, 정원이 마감되었는지 확인해야 하고, 스터디가 오픈 된 후에 추가로 참여하는 경우를 구분하여 비즈니스 로직을 작성해야 했습니다. 처음에는 모놀리틱 코드로 service파일에 모든 로직이 있었습니다. 분리가 제대로 돼있지 않아서 같은 로직이 여러 곳에 있기도 하는 등 관리가 전혀 안됐습니다. 클린 아키텍처를 적용하면서 Study 도메인이 만들어졌고, 스터디를 참여할 때 검증 하는 과정, 스터디 오픈 후 참여하는 과정 등 핵심 비즈니스 로직은 이 도메인에 포함되었습니다. 그리고 service 코드에서는 이 domain을 사용하여 비즈니스 로직을 실행했습니다. 또한 DB에 접근하는 코드는 repository로 분리하고, interface를 정의하여 의존성을 역전 시켰습니다. 그렇게 DB의존성을 분리할 수 있었고, 코드의 책임 또한 분리할 수 있었습니다.

## "DDD와 클린 아키텍처를 적용하면 **초기 개발 단계에서 설계가 복잡해지고 코드량이 늘어나는 트레이드오프**가 있습니다. 이로 인해 개발 속도가 저하되지는 않았나요? 그럼에도 불구하고 이 설계를 선택한 이유와, 동료들을 어떻게 설득했는지 궁금합니다."

중간에 리팩토링을 했습니다. 초기에는 그런게 적용돼있지 않았습니다. 사실 전환할 때 반대도 있었습니다. 모놀리틱 구조에 익숙해지고, 규모가 너무 크지 않다면 모놀리틱에서 코드를 수정할 때 더 편하기도 하기 때문이었습니다. 또한 신규기능개발  그 기간동안 못합니다. 하지만 저는 점점 유지보수에 들어가는 시간이 늘어난다는걸 느꼈고, 이러한 전환이 필요하다 생각하여, 장점을 설명하고 기간을 잡아 설득했고, 성공적으로 전황할 수 있었습니다. 

## - "클린 아키텍처의 **'의존성 역전 원칙(DIP)'**이 구체적으로 이 프로젝트의 '유지보수성'에 어떻게 기여했는지 실제 사례를 들어 설명해 주시겠어요?"

가장 크게 적용된 부분은 Repository 코드의 분리입니다. DB의존성을 제거하기 위해 이러한 구조를 만들었습니다. 저희 서비스가 MongoDB를 사용하고 있는데, Mysql을 사용하는 것이 논의된 적이 있었고, 언제든 이러한 요구에 대응할 수 있는 구조를 갖추고 싶었습니다. 그래서 interface를 먼저 정의하고 Nest.js에서 의존성을 주입받아 service에서 사용했습니다. 구현체에서도 DB모델과 도메인 모델 사이의 전환하는 로직을 넣어둬서, service코드에서는 DB의 구조를 모르고 도메인 모델을 사용할 수 있도록 구조를 갖췄습니다. 그 외에도 일부 날짜 라이브러리를 사용할 때 직접 사용하지 않고, interface를 정의해서 사용하기도 했는데, 많이 적용되어 있지는 않습니다.


## "Heroku에서 AWS EC2로 이전하며 **월 100달러의 비용을 절감**했다고 하셨습니다. Heroku는 PaaS로 운영 편의성이 높은데, EC2(IaaS)로 이전하면 **OS 패치, 보안 설정, 로깅 등 직접 관리해야 할 부분이 늘어나 오히려 운영 비용(시간)이 증가**할 수 있습니다. 이러한 단점은 어떻게 극복하셨나요?"

초기 세팅이 조금 어려운 점은 있지만, 한번 구축해두면 장기적으로 많은 비용을 아낄 수 있기 때문에 도입했습니다. CI/CD파이프라인을 구성하기 위해, AWS Codepipeline을 사용했습니다. github의 특정 리포의 브랜치를 연동해서 변경이 생기면 트리거가 되고, 프로젝트에 정의된 build script가 실행됩니다. 이 build과정에서 docker image를 빌드하고 AWS의 ECR에 저장합니다. 그 다음 deploy script가 실행되는데, 이 때 ecr에서 이미지를 내려받아 온 다음, docker로 실행하여 container 형태로 배포하도록 되어있습니다. 

## "AWS CodePipeline을 사용하셨는데, 3번 문단의 Jenkins와 비교했을 때 **CodePipeline을 선택한 특별한 이유**가 있나요? 두 도구의 장단점을 아는 대로 설명해 주세요."

먼저, AWS를 선택한 이유는 저희가 서비스를 AWS EC2와 통합이 쉬웠기 때문입니다. Jenkins를 사용한다면, Jenkins 버전관리나 플러그인을 관리해야 해서 관리 비용이 더 증가할 것이라 생각했습니다. 반면, CodePipeline을 사용한다면, script를 사용해 파이프라인을 정의하면 되기 때문에 훨씬 편리하다고 생각했습니다. 또한 IAM, s3, ecr과의 통합도 Codepipeline이 더 편리하다고 생각했습니다. 

Jenkins는 다양한 플러그인 생태계가 있어 유연합니다. AWS, GCP등 어떠한 환경과도 통합되어 배포가 가능하고, 무료입니다. 하지만 많은 운영 리소스가 필요합니다. 
반면, Code pipeline은 AWS 서비스들과 통합이 쉽고, AWS가 관리해주는 부분이 있어, 사용자는 파이프라인에만 집중하면 됩니다. 

## "비용 절감 외에, Heroku를 사용할 때와 비교하여 AWS EC2로 이전한 후 **기술적으로 가장 크게 개선된 점(예: 성능, 확장성)**은 무엇이었나요?"

Heroku로 배포할 때는, 서비스를 하나 씩 분리해서 배포해야 하고, 데이터베이스는 따로 외부에서 사용하거나 해야했습니다. 반면, EC2를 사용할 때는, 하나의 인스턴스에 프론트엔드 백엔드를 모두 배포할 수 있었고, 또 서비스에 공간이 남는다면, 데이터베이스나, Docker 같은것도 사용할 수 있는 등 자유도가 높았습니다. 또한 ELK 스택처럼 자체적으로 모니터링 시스템 등을 구축할 수 있었던 것도 도움이 됐습니다. 

## "ArgoCD를 스터디하고 Spring 프로젝트에 적용해 보셨다고 했습니다. **ArgoCD(GitOps)** 기반의 배포 방식은 기존의 **CodePipeline(Push 방식)**과 비교했을 때 어떤 근본적인 차이점이 있으며, ArgoCD를 도입했을 때 개발자/운영자 입장에서 얻는 **가장 큰 이점**은 무엇이라고 생각하시나요?"

가장 큰 차이는 배포를 실행하는 주체와, 어디를 신뢰하느냐 라고 생각합니다.

기존 방식은 CI/CD 파이프라인이 주체가 됩니다. Git에 코드가 푸시되면 파이프라인이 트리거됩니다. 이는 파이프라인이 코드의 권한을 가지게 되므로 보안적으로 좋지 않을 수 있습니다.

반면, ArgoCD를 사용한 gitops방식인 kubernetes 클러스터가 주체가 됩니다. 클러스터 내부의 ArgoCD가 리포지토리를 감시하고, 변경을 반영합니다. 일치하지 않는다면 차이를 가져와서 일치시킵니다.

또한 Git이 시스템의 현재 상태이고, 유일한 진실입니다. 현재의 서버 상태가 궁금하다면 Git을 보면 되고, 오류가 생겨도 쉽게 복구할 수 있습니다. 또한 실수로 kubernetes 클러스터의 상태를 변경해도, ArgoCD가 자동으로 복구시킵니다. 그리고 CI/CD파이프라인에게 클러스터를 관리할 권한을 주지 않아도 됩니다.

## "Kubernetes 환경에서 GitOps를 구성하면서 **가장 어렵거나 복잡했던 부분**은 무엇이었으며, 이를 어떻게 해결하셨나요?"

환경변수 관리가 조금 어려웠습니다. 모든 설정을 git에 둬야하는데, DB비밀번호 같은 민감 정보를 git repository에 저장할 수가 없었습니다. 다양한 방식을 검토했고, AWS Secrets Manager를 사용한 방식과 Sealed Secret 방식을 알게됐습니다. 그리고 그 중에 kubernetes에 쉽게 통합할 수 있는 Sealed Secret 방식을 선택했습니다. kubernetes 내부에 Sealed Secret 컨트롤러를 설치합니다. 개발자는 kubeseal이라는 도구를 사용해서 secret파일을 암호화합니다. 그 결과로 sealedsecret 파일이 생성되는데, kubernetes내부에서 이를 private Key로 복호화해서 사용합니다. 

## "LG CNS는 대규모 클라우드 전환 프로젝트를 수행합니다. 만약 수백 개의 마이크로서비스를 운영해야 한다면, **기존의 CI/CD(Jenkins, CodePipeline) 방식**과 **GitOps(ArgoCD) 방식** 중 어떤 것을 제안하시겠습니까? 그 이유를 **'안정성'**과 **'확장성'** 관점에서 설명해 주세요."

GitOps방식을 사용할 것입니다. GitOps방식에서는 Git이 단일 신뢰 출처로 여겨집니다. 그래서 각각의 서비스를 별도로 배포할 필요 없이, Git에 정의해두면 항상 일관된 상태로 여러개의 서비스를 배포할 수 있습니다. 또한 운영상태를 버전 관리할 수 있어 쉽게 롤백 가능합니다. 

CI/CD방식은 파이프라인이 많아질수록 관리가 급격히 어려워집니다. 

## 1문단의 **'견고한 설계(DDD)'**, 2문단의 **'비용 최적화(AWS)'**, 3문단의 **'안정적 운영(GitOps)'**은 아키텍트의 핵심 역량입니다. 하지만 **이 세 가지 가치가 서로 충돌하는 상황**도 분명히 존재합니다. (예: 가장 견고한 설계는 비용이 비싸고 운영이 복잡할 수 있음) **본인이 아키텍트라면, 이 세 가지 가치 중 어떤 것을 가장 우선시하겠습니까? 그 이유를 설명해 주세요."**

## "본인이 경험한 **'클린 아키텍처(1문단)'**가 **'컨테이너/K8s 환경(3문단)'**과 만났을 때 어떤 시너지를 낼 수 있다고 생각하시나요?"



# 자기소개서 3번
모집분야와 관련된 전공 과목 및 해당 전공과목에서 달성한 성취도(학점)를 구체적으로 기술해 주십시오. (500자)

## "C언어로 `fork()`와 `exec()`를 구현하며 프로세스 동작 원리를 이해했다고 하셨습니다. 우리가 셸(Shell)에서 `ls -l`이라는 명령어를 입력했을 때, 이 **두 시스템 콜이 어떤 순서로, 어떻게 상호작용**하여 우리 눈에 결과가 보이게 되는지 그 **내부 동작 과정**을 설명해 주시겠어요?"

ls -l을 입력하면, bash와 같은 쉘 프로세스가 이 명령을 읽습니다.
쉘인 이 ls라는 프로그램이 내부 명령어가 아닌, 외부 프로그램임을 알아챕니다.
그냥 exec()을 호출하면, 쉘이 ls로 덮어씌워지기 때문에 fork()를 먼저 호출합니다. fork()가 호출되면, 커널은 혈재 셸 프로세스와 메모리 코드, 열린 파일 등 모든 것이 같은 자식 프로세스를 생성하고, ls-l을 실행합니다.

fork가 완료되면, 똑같은 코드를 실행하는 프로세스가 두 개가 됩니다. 부모 프로세스의 fork()는 자식의 PID (0보다 큼)을 반환받습니다.
자식 프로세스는 0을 반환받습니다.

ps aux | grep "node"

## "`fork()`를 호출하면 부모 프로세스와 자식 프로세스가 생성됩니다. 이때 **자식 프로세스는 부모 프로세스의 메모리(데이터)를 그대로 복사(Copy)해서 가질까요?** 만약 그렇다면 비효율적일 텐데, 유닉스(리눅스)는 이 문제를 어떻게 효율적으로 처리하나요?"

copyonwrite 방식으로 해결합니다. fork()가 호출된 시점에는 물리적 복사가 얼어나지 않습니다. 이 때, 부모나 자식 중 쓰기가 일어난다면, 쓰기가 발생한 페이지에 새로 할당이 일어납니다. 

## "그렇다면 `fork()`만 호출한 프로세스와, `vfork()`를 호출한 프로세스는 어떤 차이가 있나요?"

vfork는 fork의 레거시 방식입니다. copy on write가 일어나지 않고, 자식과 부모가 메모리를 공유합니다. 자식이 exit 할 때까지 부모는 무조건 정지합니다.

## "대용량 `nginx`의 `access.log` 파일이 있습니다. 이 파일에서 **'404 Not Found' 에러**를 발생시킨 **클라이언트 IP**를 **중복 없이** 세어서, **가장 많이 요청한 순서(Top 10)**로 정렬하는 셸 명령어 한 줄을 만들어 보시겠어요?"

awk '$9 == "404" {print $1}' access.log | sort | uniq -c | sort -nr | head -n 10
cat access.log | grep | sort

grep " 404 " access.log | cut -d' ' -f1 | sort | uniq -c | sort -nr | head -n 10

## "방금 말씀하신 `sort`와 `uniq` 명령어의 순서를 바꾸면 (즉, `sort` 전에 `uniq`를 먼저 쓰면) 왜 원하는 결과가 나오지 않는지 설명해 주세요."

## "애플리케이션 배포를 자동화하는 셸 스크립트를 작성했다고 하셨습니다. 그 **스크립트가 수행하는 구체적인 작업(Logic)들**을 순서대로 설명해 주세요."

먼저, git과 docker hub에 접근할 수 있는 인스턴스 환경이 세팅돼있어야 합니다. 

먼저 git pull로 git repository에서 소스코드를 가져옵니다. spring 프로젝트를 gradle build로 빌드파일을 만들어줍니다. 그 다음, docker image build 명령을 실행합니다. Dockerfile이 저장되어 있어야합니다. dockerhub에 인증을 하고 로그인을 합니다. 이때 비밀번호는 jenkins의 환경변수에 저장해뒀습니다. docker hub에 푸쉬합니다. 기존 컨테이너가 실행중이면 삭제합니다. 그런 다음 새 컨테이너를 실행하는 docker run 명령을 실행합니다. 

## "그 스크립트를 작성하면서 **가장 처리하기 까다로웠던 예외 상황**은 무엇이었고, 이를 **안정적으로 처리하기 위해 어떤 방어 코드**를 넣었나요?"

배포가 실패했을 때 처리를 생각하는 부분이 조금 어려웠습니다. 
맨 상단에 set -e와 같은 구문을 넣어두지 않는다면, script 중간에 docker build가 실패해도 멈추지 않아 문제가 발생했습니다. 컨테이너 삭제 명령은 컨테이너가 없어 실패해도 동작해야 합니다. 그래서 OR true 와 같은 구문을 작성하여 방어했습니다. 
## "유닉스 프로그래밍 지식이 LG CNS의 **클라우드 아키텍트** 직무를 수행하는 데 **구체적으로 어떤 도움**이 된다고 생각하시나요?"

아키텍처로 일하게 된다면, 클라우드 환경에서 가장 많이 일하게 될 것입니다. 그리고 이러한 클라우드 환경은 대부분 리눅스 기반의 운영체제를 사용합니다. pipe grep awk 와 같은 명령을 알고 있다는 것은, 이러한 환경에서 로그데이터를 찾아 빠르게 에러를 진단할 수 있을 것입니다. 또한, 시스템 자동화를 위해서는 쉘 스크립트를 작성하는 일도 많을것이라 생각합니다. 이럴 때, 유닉스 프로그래밍에서 배운 지식이 많이 도움이 될 것입니다. 

## - "요즘은 Docker, Kubernetes(K8s)처럼 잘 추상화된 환경에서 일합니다. 이런 환경에서도 아키텍트가 `fork()` 같은 **로우 레벨(Low-level)의 시스템 콜**이나 **프로세스 동작 원리**를 알아야 할 필요가 있을까요? 만약 필요하다면 **어떤 상황에서** 그 지식이 빛을 발할까요?"
_(Hint: 컨테이너 내부의 비정상적 프로세스 동작, 리소스(CPU/Memory) 사용률 급증 원인 분석, 경량화된 컨테이너(Alpine) 환경에서의 트러블슈팅 등)_

또, docker나 kubernetes환경에서 작업을 하다보면, 애플리케이션이 running으로 나오는데 실행이 안되는 경우가 있습니다. 그런 경우에는 exec과 같은 명령을 사용해서, 컨테이너 안으로 접속해서 보는것이 도움이 됩니다. 

ps aux | grep

# 자기소개서 4번
최근 3년 이내 수행한 개발 프로젝트 중, 본인이 핵심적으로 기여한 사례를 1개 선택하여 사용 언어 및 기술, 본인의 역할, 문제 해결 과정, 최종 성과를 중심으로 구체적으로 작성해 주세요. (개발 경험이 없거나 Consulting 직무 지원자의 경우, 지원 직무 관련 프로젝트 참여 경험에 대해 상세히 작성해 주세요.) (1000자)

## Express.js에서 Nest.js로 마이그레이션하면서 '잦은 서버 다운'이 발생했다고 하셨습니다. 마이그레이션 작업과 서버 다운 사이에 **어떤 구체적인 인과관계**가 있었나요? Nest.js의 어떤 특징(예: 복잡한 DI 구조, 메모리 누수)이 문제의 원인이었나요, 아니면 단순히 마이그레이션 과정에서 발생한 코드의 버그였나요?"

Express.js와 Nest.js의 에러 핸들링 방식의 차이 때문이었습니다.
저는 Express.js의 5이전 버전을 사용했었습니다. 여기서는 비동기 에러가 자동으로 감지되지 않기 때문에, try, catch문으로 에러를 잡아서, next(err)를 명시적으로 호출해줘야 했습니다. 그 후, 에러 처리 미들웨어에서 이를 처리해줬습니다. 
Nest.js는 에러를 throw하는 방식을 사용합니다. 그래서 try catch문 중 일부를 없애고 에러가 발생할 수 있는곳에서 throw를 한 뒤, Exception Filter를 등록해서 전역 에러 핸들링을 해주었습니다. 근데 이 때 일부 에러가 handling되지 않았고, 이런 에러들이 서버 다운을 일으켰습니다. 해결방법을 찾아보니, 핸들링되지 않은 에러를 전역에서 처리해주는 이벤트 리스너가 잇었습니다. 그래서 이를 로깅하여 해결했습니다. 

Spring도 ControllerAdvice 어노테이션을 사용해서, 전역에서 에러를 핸들링할 수 있습니다. try catch문 등으로 throw하면 여기서 처리합니다. 혹은 controller별로 controller 에러 핸들러를 등록할수도 있습니다. 
## "서버가 다운될 정도의 문제였다면, **왜 Express.js를 Nest.js로 마이그레이션하기로 결정**하셨나요? Nest.js를 도입해서 얻으려고 했던 '기술적 이점'은 무엇이었고, 그 이점이 '서버 다운'이라는 위험을 감수할 만큼 가치가 있었다고 판단하셨나요?"

처음에는 코드에 별다른 구조가 없었습니다. service코드에서 대부분의 로직을 처리했기 때문에, 비즈니스 로직이 이곳저곳에 존재하고, 코드 관리가 점점 힘들어졌습니다. 그 무렵 클린아키텍처 책을 접하며, 코드 설계에 관심을 가지게 됐습니다. 그리고 배운걸 적용해보고 깔끔한 구조를 갖추기 위해, 여러차례 리팩토링을 시도했습니다. 가장 큰 부분은 의존성 역전을 통한 의존성 제거였습니다. 외부 라이브러리나 DB에 코드가 의존하지 않는 구조를 만들었습니다. 또한, Domain을 정의해서 서비스의 핵심 기능들을 분리하고, 각 domain이 비즈니스 로직을 관리하도록 했습니다. Repository도 분리해서 DB에 접근하는 코드를 분리했고, 이런식으로 책임을 분리하고 의존성을 제거해서, 유지보수가 쉽도록 구조를 설꼐했습니ㅏㄷ


## "이 자소서의 핵심 경험이 'Logstash를 Filebeat로 대체'한 부분입니다. **Logstash와 Filebeat의 가장 큰 아키텍처적 차이점**은 무엇인가요? 그리고 **어떤 근거로 Logstash가 높은 메모리 사용량의 주범**이라고 특정(Identify)할 수 있었나요?"

LogStash는 단순히 데이터를 전달하지 않고, 데이터를 가공하는 기능을 제공합니다. 그러나 제가 수집하는 로그 데이터는 단순한 JSON 형태의 데이터였기 때문에 이러한 변환이 필요하진 않았습니다. 또한, Logstash는 JVM 기반으로 동작하기 때문에, 메모리 사용량이 메우 높았습니다. 그래서 찾은 대안이 Filebeat이었습니다. 로그를 수집하고 바로 ElasticSearch로 보낼 수 있습니다. 명령어를 잘 조합하면 간단한 변환도 수행할 수 있습니다. 저는 여기서 쓸모없는 필드를 제거하거나 JSON 구조를 간단하게 변환하는 작업을 해서 인덱싱 했습니ㅏㄷ. GO언어 기반이라 가볍습니다.

docker stats 명령으로 사용하는 메모리를 확인했습니다. 
##  "Filebeat는 로그를 수집/전달만 하는 경량 에이전트고, Logstash는 데이터를 파싱하고 가공(Transform)하는 무거운 작업을 합니다. **Logstash를 제거했다는 것은 '데이터 가공' 단계를 포기**한 것일 수 있습니다. - 

혹시 Logstash가 하던 데이터 가공 작업이 꼭 필요했다면, 이를 **어떻게 대체**하셨나요? (예: Elasticsearch의 Ingest Node 사용, Fluentd 도입 등)
    
아니면, 1번에서 언급한 '전역 에러 핸들러'로 **JSON 포맷을 표준화**했기 때문에, 애초에 Logstash의 무거운 파싱 작업이 필요 없었던 것인가요?"

## "Kibana 대시보드를 구축했다고 하셨는데, 장애를 '신속하게 파악'하기 위해 **대시보드에 어떤 지표(Metric)들을** 주로 띄워놓고 모니터링하셨나요? (예: HTTP 5xx 에러 카운트, IP별 요청 수, 응답 시간 분포 등)"

level이 error이고., code가 500-599인 최신 로그들을 볼 수 있게 구성했고, 또하나는 400번대 에러를 수집하도록 구성했습니다. 
또한, API요청 시간을 다 로깅했는데, 이 데이터를 가져와서 묶고 평균 응답시간, 최대 응답시간 이런것들을 분석했습니다. 

text: 토큰화
keyword
## "설명을 들어보면, **EC2 인스턴스 하나**에 Nest.js 애플리케이션(Docker)과 모니터링 스택(Elasticsearch, Kibana, Filebeat)을 **모두 설치한 구조**로 보입니다. 이 구조는 **단일 장애 지점(SPOF)**이라는 치명적인 약점이 있습니다. 만약 Elasticsearch가 메모리를 폭주시켜 서버가 다운되면, 정작 **장애 원인을 분석해야 할 모니터링 시스템까지 함께 다운**됩니다. 이 위험성에 대해 어떻게 생각하시나요?"

이렇게 서비스를 구성한 이유는, 좋은 아키텍처여서가 아닌 한정된 비용 안에서 모든 서비스를 운영하기 위한 차선책이었습니다. 아키텍처로 일을 하다보면 어느 상황에서든 자원이 한정적인 상황을 마주할 수 있다고 생각합니다. 그 안에서 어떻게든 최선의 아키텍처를 구성하는 것이 좋을 것이라 생각합니다. 

현재 서비스 구조는, Docker-compose를 사용하여 ELK스택은 따로 배포하고 있어, 메모리 사용량이 초과하면 ELK 스택은 다운되지만 서비스는 영향을 받지 않습니다. 메모리 리밋이 걸려있음. 

## "LG CNS의 클라우드 아키텍트로서, 현재의 '단일 EC2 인스턴스' 구조를 **'안정적이고 확장성 있는 아키텍처'**로 재설계해 달라는 요청을 받았습니다. **어떤 AWS 서비스들(ELB, ASG, RDS, OpenSearch 등)을 조합**하여 어떻게 개선하시겠습니까? 그 이유도 함께 설명해 주세요."

ELB와 ASG
인스턴스를 2대 이상 운영하고, ASG을 사용해 여러개의 인스턴스를 관리합니다. 
또한 ELB를 추가하여 트래픽을 ASG내의 EC2인스턴스에게 분산으로 넣겠습니다. 
또한 데이터베이스는 따로 운영하기 위해 RDS같은 서비스를 사용하거나, 새로운 인스턴스에 구성해두겠습니다. 

## "Nest.js에서 '전역 에러 핸들러'를 구현했다고 하셨습니다. **어떤 방식(예: Exception Filter, Interceptor)**을 사용하셨나요? 그리고 '일관된 JSON 포맷'에는 **어떤 정보들(예: timestamp, error code, stack trace, request URL)**을 담도록 설계했는지 궁금합니다."

## AA, DA, TA, DBA
AA: Application Architecture는 시스템 특징에 적합한 프로그램의 아키텍처를 설계하고, 개발팀 전원이 파악할 수 있기 UML 등으로 공유하는 사람. 표준안, 프레임웤, 테스트, 테크니션 교육 등 총괄

TA: Technical Architecture. 시스템의 기술적 토대를 설계. 서버, 네트워크, 클라우드 환경같은 인프라를 설계하고 최적화하는 역할. 부하 분산, 오토스케일링, 재해 복구

DA: Data Architecture. 데이터가 어떻게 저장되고 어떻게 활관리되며 활용될지 전체적인 구조를 설계합니다. 데이터베이스 시스템 설계및 선택. 데이터 모델링과 스키마 설계


제 그동안의 경험 등에 비추어봤을 때, 가장 자신있는 부분은 TA일 것 같습니다. 역량을 조금 더 키우면 AA 업무도 경험해보고 싶습니다.