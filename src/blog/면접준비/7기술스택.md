# Express.js
Node.js환경에서 많이 사용.
간결한 API및 웹 앱 개발

## middleware
요청과 응답 사이에서 실행되는 함수.
요청을 처리하거나 변형하고, 다음 미들웨어로 넘김
파싱, 쿠키/세션관리, 인증/권한처리, 로깅, 에러처리 등 가능

## 라우팅
요청을 특정 엔드포인트와 HTTP메서드에 따라 처리하는 방법을 정의

## 에러처리
매개변수를 4개 받는 미들웨어를 둔다.

## 라우터
라우터를 모듈화하여 구조화할 수 있다.

- 미들웨어 동작원리와 순서: 요청이 도착하면 정의된 미들웨어를 순서대로 실행.
각 미들웨어는 next()를 호출하여 다음 미들웨어로 흐름을 넘긴다.
마지막 미들웨어가 응답을 클라이언트로 보냅니다.
- Express에서 비동기 오류 처리방법: 비동기 오류를 자동으로 처리하지 않는다. 콜백함수에서 에러 응답. catch에서 에러 처리


# Nest.js
Typescript기반
MVC 구조와 유사한 모듈식 아키텍처
Dependency Injection
Express.또는 Fastify 사용가능
Decorator 기반 선언적 프로그래밍

모듈: Nest의 기본 블록. 컨트롤러, 서비스 프로바이더 관리
컨트롤러: 요청을 서비스로 전달하고 응답 처리
서비스: 비즈니스 로직 처리, DB와 상호작용
프로바이더: Nest에서 의존성 주입 담당하는 객체. 서비스, 리포지토리, 팩토리 등 제공 가능
파이프: 데이터 유효성 검사 및 변환 담당
가드: 인증 및 권한 확인 용도
인터셉터: 요청 전후로 작업 수행 가능
미들웨어: Express.js와 동일하게 동작.

Nest.js선택 이유: Typescript기반으로 안정성이 뛰어나다. 명확한 구조와 모듈화된 아키텍처를 제공한다. DI, 인터셉터등 기능을 제공하여 의존성 분리, 생산성을 높일 수 있다.

의존성 주입: 객체를 직접 생성하지 않고, 외부에서 제공받는 설계 패턴입니다. 의존성 역전을 위해 필요합니다. 세부 구현을 직접 참조하지 않고 상위 인터페이스를 참조하도록 하여 변화에 영향을 덜 받도록 설계할 수 있습니다.

Pipe의 역할: 데이터 유효성 검사와 데이터 변환을 담당합니다. 주로 요청 데이터가 올바른지 검증하거나, 필요한 타입으로 변환할 때 사용합니다.

# MySQL
인덱스는 데이터 조회 속도를 높이기 위해 사용되는 자료구조입니다.
B-Tree 구조를 사용하여 데이터를 빠르게 탐색합니다.
B-Tree: 모든 리프가 같은 레벨 가질 수 있도록 자동 조정하는 트리
검색 조건, 정렬, JOIN에 사용되는 컬럼에 인덱스 설정하면 성능이 향상된다.
데이터의 추가/수정/삭제가 빈번한 컬럼에 과도한 인덱스를 설정하면 성능이 저하될 수 있다.

자주 조회되는 컬럼에 우선적으로 적용하고, 카디널리티가 낮은 컬럼에 선택
복합 인덱스는 컬럼의 순서가 중요
너무 많은 인덱스는 저장공간 증가, INS/UPD성능 저하시킬 수 있다.

JOIN 컬럼에 인덱스를 설정하여 JOIN 성능을 크게 개성할 수 있습니다.
JOIN 전 필터링을 먼저 수행하여 JOIN 시 처리해야 할 데이터 양을 최소화합니다.
필요 없는 데이터는 JOIN 이전에 WHERE 조건으로 필터링합니다.
복잡한 JOIN 쿼리는 서브쿼리나 임시 테이블을 사용하여 단계적으로 수행합니다.

트랜잭션: 원자성, 일관성, 고립성, 지속성

MySQL의 락
- 공유 락: 데이터 읽기 작업에 사용.
- 베타적 락: 데이터 변경 시 사용
- 낙관적 락: 충돌이 적은 환경에서 주로 사용. 버전 번호 등을 통해 충돌을 감지하여 제어.

데드 락: 두 개 이상의 트랜잭션이 서로 상대가 보유한 리소스를 기다리며 무한 대기하는 상황
- 일정한 순서로 리소스를 확보하도록 함.
- 락 타임아웃을 설정하여 오래 기다리지 않게 함.
- 트랜잭션을 작게 하여 락 보유 시간을 최소화

데이터 무결성을 위해 할 수 있는것: 기본키, 외래키, 데이터 타입 제한 및 제약조건 설정. Trigger를 사용한 데이터 무결성 검사 로직 구현

# MongoDB
Document기반의 비관계형 데이터베이스

Document-oriented: JSON 형태로 데이터 저장
스키마가 고정되지 않아 자유롭게 추가, 변경 가능
Sharding과 Replica Set으로 수평 확장 가능
Aggregation Framework: 복잡한 데이터 집계 및 분석 처리 제공
빠른 개발 속도: 복잡한 JOIN 없이 데이터를 직관적으로 저장하고 조회 가능

Document: 데이터의 기본 단위
Collection: Document를 모아놓은 곳
Database: Collection을 담는 컨테이너
Field: 키-값 형태의 데이터 항목
Index

여러 단계의 데이터 처리 작업을 수행할 수 있는 파이프라인 방식의 데이터 처리 기능입니다.

사용자의 스터디 참여 통계 등을 계산할 때 Aggregation Pipeline을 구성하였습니다.

자주 조회되거나 필터링에 사용되는 필드에 인덱스를 설정합니다.

복합 인덱스로 여러 필드를 결합하여 조회 성능을 높일 수 있습니다.

Replica Set: 데이터 복사본을 여러 노드에 복제하여 주 노드가 장애 발생 시 보조 노드가 자동으로 인계받아 서비스 연속성을 보장합니다.
Sharding: 데이터를 여러 서버에 분산 저장하여 데이터 처리 및 확장성을 극대화 하는 방법입니다.

MongoDB 스키마 설계시 고려할 것
- 쿼리 성능을 우선적으로 고려합니다.
- JOIN 사용을 줄이고, 자주 사용하는 데이터를 가능한 Document 내에 임베딩 합니다.
- 데이터 중복을 허용하되, 자주 바뀌는 데이터는 임베딩하지 않고 참조 합니다.
- Document 크기가 16MB를 넘지 않게 설계합니다.
