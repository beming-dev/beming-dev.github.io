제가 주식에 관심이 많은데, Spring과 Mysql을 공부하면서 해볼만한 개인 프로젝트를 떠올리다가 주식 시뮬레이션 프로그램이 딱이라 생각하여 개발을 시작하게 됐습니다.

Spring을 이용한 API 개발 경험을 쌓았습니다.

Inversion Of Control:  객체의 생성, 생명주기 관리를 프레임워크가 담당
DI: IOC의 핵심 개념. 의존 객체를 외부에서 주입받아 사용.

스프링 컨테이너: 스프링 프레임워크의 핵심 개념. Bean을 생성, 관리, 소멸 등 라이프사이클을 담당함 EX) Application Context.
빈 생명주기(생성-> 의존관계 주입 -> 초기화 -> 사용 -> 소멸) 전 과정을 관리

빈: 컨테이너를 생성하고 관리하는 객체

AOP: 애플리케이션 전반에 걸쳐 반복되는 기능을 Aspect로 분리해 관리하자. "어디서", "언제" 적용할지를 비즈니스 로직 코드와 분리하여 관리함. 코드를 깔끔하고 재사용 가능하게 만듦.

Aspect: 관심사를 모듈화한것
Advice: 공통 기능이 실행되는 지점
PointCut: 어느 메스드에 대해 Advice를 적용할지 결정
Join Point: Advice가 삽입될 수 있는 모든 지점
Weaving: AOP를 적용하여 Aspect를 연결하는 과정

스프링은 프록시 기반 AOP방식을 사용.

MVC 패턴: 역할과 책임을 분리하여 유지보수성, 확장성을 높인다.

Model: 데이터, 비즈니스 로직
View: 사용자에게 보여지는 화면
Controller: 사용자 요청을 받고, 적절한 Service, Model 로직을 수행한 뒤 결과를 View에 전달.

DispatcherServlet: 스프링 MVC의 프론트 컨트롤러. 모든 요청을 받아 Controller로 매핑
핸들러 매핑: 어떤 URL 요청이 어느 컨트롤러 클래스로 전달될지 매핑 정보 관리

스프링부트: 스프링 프레임워크를 간편하게 사용하도록 도와줌
톰캣 등 내장 웹 서버 제공, 자동 설정, 스타터 의존성 관리 등을 통해 간단한 설정으로 바로 실행 가능

트랜잭션: 선언적 트랜잭션을 통해 쉽게 적용가능. Transactional 어노테이션으로, 해당 메서드 실행 지점에서 프록시로 트랜잭션 시작하고, 메서드가 정상 종료되면 커밋, 예외 발생 시 롤백

# WebSocket 
하나의 TCP 연결로 클라이언트와 서버가 지속적으로 실시간 데이터를 전송할 수 있는 프로토콜
실시간 양방향 데이터 전송 프로토콜

HTTP는 매 요청마다 연결과 응답이 끝나면 다시 연결을 맺어야 함.
polling 방식은 서버의 자원을 많이 사용한다.

1. WebSocket 핸드쉐이크:HTTP request를 보내면서 WebScoket 프로토콜로 업그레이드를 요청
2. WebSocket Frame 형태로 데이터 주고받음.
3. 연결 종료 시, Close Frame을 보내 연결을 끊는다.

주식 데이터와 같이 빠른 실시간 데이터 전달이 중요할 때 WebSocket 사용가능

처음 구조를 설계했을 때, 여러명의 클라이언트가 같은 주식 페이지에 접속하면, 같은 WebSocket 연결이 여러개 생성되어서 같은 데이터가 중복으로 전송되는 문제가 있었습니다.

이 문제를 해결하기 위해, 서버와 외부 api와의 연결이 여러개 생성되지 않도록, 구독 형태를 구현했습니다.
먼저 클라이언트가 특정 주식데이터 구독을 요청하면, 어떤 주식인지와 어떤 요청인지 정보를 합쳐 key를 만듭니다. 그 key를 기반으로 그 키에 해당하는 서버, 외부 사이의 websocket 연결이 없다면, 새로 연결을 생성하고, 요청을 보낸 클라이언트를 첫 구독자로 둡니다. 만약 이미 연결이 존재한다면, 그 요청을 구독합니다. 그리고 WebSocket을 통해 데이터가 전송되면 서버가 구독자들에게 데이터를 뿌려줍니다.
# React 상태관리

React의 Context API를 사용하여 인증상태, WebSocket 연결을 관리했습니다.

context를 생성하고, Provider로 앱 전체에서 공유할 수 있게 함.

# Jenkins
