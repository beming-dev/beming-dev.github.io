더 적은 인력으로, 더 결함율이 낮고 더 빠르게 개발할 수 있는 코드를 작성하자.

의존: 다른 코드를 참조하여 이용하는 것. Java의 import, Javascript의 require import, C의 include
	B모듈이 A모듈을 import 한다면, B 모듈은 A모듈에 의존하는 것입니다.

B모듈은 여러 모듈을 import해서 사용하고 있고 아무도 B를 import하지 않습니다. A모듈은 아무것도 import 하지 않지만 여러 모듈이 A를 import합니다.

이 때, A를 안정적이라고 합니다. 안정적인 모듈은 변경이 어렵습니다. B모듈은 불안정하다고 합니다. 우리는 B 모듈을 마음껏 변경할 수 있습니다.

우리는 코드를 불안정한 부분과 안정한 부분 두 부분으로 분리해야 합니다.


# DIP 의존성 역전 원칙

구현체는 자주 변하지만, 추상화는 변하지 않습니다.
=> 구현체를 불안정한 모듈, 추상화를 안정된 모듈로 만들면 좋은 코드를 만들수 있을까요?

모든 코드는 구현체가 아닌 추상화에 의존해야 합니다.

여기까진 좋지만 그러면 추상화에 의존하는 코드는 구현체를 어떻게 알까요? 알 방법이 없습니다.
누군가는 구현체의 내용을 알려줘야 합니다.

이 역할을 하는 것이 바로 EntryPoint 입니다 보통 main 이라고 합니다.
main이 모든 모듈들의 구현체를 만든 뒤, 의존성을 잘 주입한 다음 구현체에게 제어권을 넘겨주면 됩니다.
main은 구현체에 직접 의존하게 되지만, main이 모두 감당하면 다른 코드가 좋아지므로 괜찮습니다.


# 정책
모든 코드는 정책을 담고 있습니다.
이 정책은 중요한 정책과 덜 중요한 정책으로 나눌 수 있습니다.
중요한 정책은 업무 규칙, 덜 중요한 정책은 세부사항 이라고 부릅니다.

애플리케이션을 만들 때, 세부사항까지 모두 미리 고려하여 제작할 수 있을까요?
절대 불가능합니다. 결정은 언제나 바뀔 수 있습니다.
세부사항을 먼저 결정하는 일이 발생하면, 결정이 바뀌었을 때 모든 코드를 수정해야 할지도 모릅니다.
오히려 이런 세부사항의 결정은 끝까지 미루는것이 바람직합니다.
여기서의 세부사항에는, 프레임워크, 웹서버, 데이터베이스 등을 포함할 수 있습니다.

그렇다면 이런 세부사항은 정책에 어떻게 결합해야 될까요?
클린 아키텍처에서 제안하는 방식은 "플러그인 아키텍처" 방식입니다.
"프레임워크나 데이터베이스 등 세부사항은 나중에 결정하고, 유즈케이스 먼저 구현하라"

소프트웨어는 유즈케이스를 위해 존재합니다.
좋은 아키텍처라면 유즈케이스가 핵심적인 위치에 존재해야 합니다.

# 클린 아키텍처

클린 아키텍처의 핵심은 다음과 같습니다.
```
소스코드 의존성은 반드시 안쪽으로, 고수준의 정책을 향해야 한다.
```
내부의 원에 속한 요소는, 외부 원에 대해 어떤것도 알지 못해야 합니다.
원의 개수는 중요하지 않습니다.

![](../images/20250314203710.png)
## 엔티티
애플리케이션의 핵심 중의 핵심이 되는 업무 객체입니다.
예들 들어, 배달 서비스라면 음식점과 주문자 의 존재 정책이 엔티티가 될 수 있습니다.

## 유즈케이스
유즈케이스는 애플리케이션의 핵심 업무 객체입니다.
앤티티는 애플리케이션이 없어도 존재해야 하지만, 유즈케이스는 애플리케이션에서 제공하는 기능입니다.
"예를 들면 장바구니에 음식을 담는다" 와 같은 행위입니다.

## 어댑터
유즈케이스가 올바르게 동작하기 위해서는, 사용자 인터페이스와 데이터베이스가 소통해야 합니다. 유즈케이스가 GUI와 데이터베이스 사이에서 브릿지 역할을 해 주는 것이 어댑터 레이어입니다.
controller의 코드가 어댑터가 될 수 있습니다.

## 세부사항
웹, 데이터베이스, 프레임워크 등입니다.
업무규칙보다 중요하지 않습니다.

# Nest.js가 클린 아키텍처 개념 적용을 어떻게 도와줄까?

## 모듈 기반 구조
기능 단위로 모듈을 분리해, 관련된 관심사만 다루게 됩니다.9
기능별 응집도가 높아지고, 모듈간 결합도는 낮아져 도메인 로직을 독립적으로 유지하기 쉬워집니다.

## 의존성 주입
의존성 주입 컨테이너를 제공하여, 클래스 사이의 결합을 낮추고 테스트 유지보수가 쉬워진다.
Controller, Service에서 DB접근, 외부 API 호출 등을 직접 구현 불가. Provider 인터페이스 주입받아 사용.
