## 자기소개


안녕하십니까 이번 카카오 신입 공채 Tech 직무에 지원한 채민관입니다.

저는 개발자로서 두가지 핵심 역량을 기르기 위해 노력해 왔습니다.

첫째, 안정적인 서비스 운영 역량입니다. 수 년간 수천명의 대학생이 이용하는 대학생 모임 플랫폼을 운영하며 이러한 역량의 중요성을 느끼고, 또 배울 수 있었습니다. 서비스 운영 중 발생하는 에러에 대응하기 위하여, ELK 스택을 도입하여 Docker의 log를 실시간으로 웹상에서 확인할 수 있는 인프라를 구축하였습니다. 또한 이를 활용하여, 응답속도가 느린 API에 Redis 캐싱을 적용하고, 응답속도를 60%이상 개선하기도 하였습니다.

둘째, 의사소통으로 협업을 만드는 역량입니다. 저는 네덜란드로 교환학생을 다녀온 경험이 있습니다. 그 과정에서 창업 수업을 수강하며 다양한 문화의 친구들과 온라인 헬스 플랫폼 프로젝트를 진행했습니다. 이러한 경험을 통해 제가 어디에든 적응할 수 있다는 자신감과, 어디에서도 의사소통으로 협업할 수 있다는 자신감을 얻었습니다. 

이러한 저의 경험을 바탕으로, 카카오에서도 동료들과 효율적으로 협업하고, 안정적으로 서비스를 운영하며 혁신적인 가치를 제공하는 개발자가 되고 싶습니다. 감사합니다.


---

## 카카오에 지원한 이유
## 꼭 우리회사여야 하는 이유

제가 카카오에 가장 큰 매력을 느낀 점은, 끊임없이 왜라는 질문을 던지며, 기술적으로 더 나은 것을 찾아가려 하는 문화 때문입니다. 

저 역시 개발자로서 공부하며, 단순히 코드를 짜는 것을 넘어 왜 이런 기술 스택을 사용해야 하고, 왜 이런 아키텍처를 설계해야 하는지 끊임없이 질문하며 성장하고 있습니다. 그래서 이러한 문화를 가진 곳이라면, 저의 역량을 최대로 발휘하여 성장할 수 있다고 생각했습니다.

그리고 저는 카카오가 단순 메신저 앱을 넘어, 국가 인프라를 담당하는 역할로 성장하고 있다고 생각합니다. 그렇기 때문에, 대규모 트래픽 상황에서의 안정적인 서비스 운영에 대해 그 어떠한 기업보다 고민했을 것이고, 앞으로도 끊임없이 더 나은 구조에 대해 고민하며 성장하는 기업일것이라 생각합니다. 

그래서 저는 이러한 성장의 기회를 제공하는 카카오에서, 개발자가 마주할 수 있는 다양한
문제들을 직접 경험하고, 국내 최고의 개발자들과 함께 끊임없이 고민하고 해결하며 회사와 함께 성장하는 경험을 하고 싶어 카카오에 지원하였습니다.





## 이 문제들을 어떤 아키텍처, 인프라로 해결할 수 있을까요?

단계적으로 생각을 해보면, 가장 간단하게 생각할 수 있는 것은 오토스케일링 입니다. 더 많은 인스턴스, 자원이 요청을 해결할 수 있게 합니다.
그 다음으로는 인프라를 추가하여 해결하는 방법도 있을 것 같습니다. 메시지 큐를 추가하여, 조금 시간이 걸리더라도, 요청을 메시지 큐에 넣고 큐에 쌓인 메시지를 consumer가 처리하는 방식입니다. 오토스케일링과도 결합될 수 있습니다.
혹은 Kafka 같은 것을 이용해서 비동기적으로, 메시지를 보낸 사람에겐 메시지가 전송됐다고 알려주고, 조금 늦게 상대에게 메시지가 도착하는 방식도 있을 것 같습니다.
그리고 이런 방식들까지 전부 안될 경우를 대비하기 위해선, 서버가 감당할 수 없는 트래픽은 거절하는 것 또한 방법일 것입니다. 사용자들에게 불편감을 줄 수는 있겠지만, 서비스 전체가 다운되는 것보다는 좋을 것이므로 트레이드 오프를 생각했을때, 이런 대비책도 마련돼있으면 좋을것 같습니다.

## 어떤 팀에서 일하고 싶은가요?

카카오 본사에는 내부에 정말 많은 팀이 있다고 들었습니다. 저는 그 중에서 채팅팀과 인프라를 관리하는 팀에서 일을 해보고 싶습니다.

먼저, 카카오의 채팅 서비스는 가장 근본이기도 하고 오래된 서비스인 만큼, 개발자들의 더 나은 구조를 위한 많은 고민과 노력이 집약 돼있을 것입니다. 그리고, 특정 시간이나 이벤트에 갑자기 많은 채팅이 전송되는 스파이크 트래픽 상황을 극복하기 위해 인프라 적으로도 어떻게 구성이 돼있을지 이런 부분을 경험해보고 싶고, 또 저도 더 나은 구조에 관해 끊임없이 고민해보고 싶습니다.

그리고 인프라를 담당하는 시스템 엔지니어 팀은 카카오 서비스의 전반적인 안정성을 담당한다고 들었습니다. 서비스 개발에 필요한 최적의 아키텍처를 설계하고 구축하며, 운영 중인 시스템의 성능 최적화까지 담당하는 일은, 개발자로서 폭넒은 기술 스택을 익히고, 어떤 상황에 어떤 기술 스택이나 아키텍처를 사용해야 할지 결정할 수 있는 판단력을 높여줄 것이기 때문에 일해보고 싶습니다.

%% 그리고 광고  서비스는 %% 
## websocket 많아지면
connection layer와 business layer를 분리

redis같은 곳에 세션 정보를 저장하여, 유저가 어떤 서버에 연결되어 있는지 찾을 수 있어야 함. 상태를 가지게 됨

메시지 브로커 사용
## 원하는 팀에 배치되지 않을 경우?

솔직히 말씀드리면, 선호하는 팀은 있지만 어떤 팀에 배치되어도 즐겁게 일할 자신 있습니다.
카카오 자체가 워낙 거대한 서비스이기 때문에, 작은 기능이라도 데이터의 양과 복잡도가 달라 일반적으로 API 개발을 하는 것보다는 고차원적인 고민과 경험 통해 성장할 수 있을 것이라 생각합니다.
그리고 카카오의 문화 자체가 더 나은 기술적 선택을 위해 왜라는 질문을 던지며 끊임없이 고민하는 곳이기 때문에, 어떤 팀에 배치되어도 최고의 성장 환경을 제공할 것이라 생각합니다. 
%% 또한 국내에서 정말 뛰어난 개발자들이 일하는 곳이기 때문에, 코드에 집약된 도메인 지식이나 구조를 이해하는 것이, 제가 개발자로서 더 넓은 시야를 가지게 해줄 자산이 될 것이라 생각합니다. %%
그래서 원하는 직무에 배치되지 않더라도, 주어진 직무에서 책임감을 가지고 일하고, 또 배울 수 있는 것들을 배워 카카오에 기여하고 싶습니다.

## 서버, 인프라를 선호하는 이유


## 원하는 직무에 배치되지 않을 경우?

제가 가장 선호하는 분야는 서버와 인프라이고, 그 외에는 플랫폼과 클라이언트 직무가 있는 것으로 알고 있습니다.
저는 이 직무들이, 서비스를 이루는 거대한 하나의 생태계이기 때문에 어떤 직무로 배치되어도 그 안에서 많은 배울점들이 있을 것이라 생각합니다.
플랫폼 분야는, 제가 CI/CD 파이프라인을 구축한 경험이 있어 금방 적응할 수 있을 것입니다. 데이터 엔지니어링은 제가 부족한 부분이 많지만, Kafka나 Airflow같은 서비스는 이용해 본 경험이 있기 때문에, 이를 바탕으로 빠르게 적응하고 그 안에서 가치를 만들겠습니다.
클라이언트 분야 역시, 저도 프론트엔드 개발을 했었고, 백엔드 지식도 있기 때문에 소통, 적응에 큰 어려움은 없을 것입니다. 그리고 사용자들에게 원활한 서비스를 제공하기 위해, 클라이언트 측에서도 최적화를 위해 많은 부분을 고민해야 할 것이라 생각합니다. 제가 성장하고 싶은 분야가 대용량 트래픽을 경험하며 비즈니스 로직을 보호하는 아키텍처를 설계하는 것이라 그 부분은 조금 아쉽지만, 주어진 직무에서 최선을 다하고, 다른 직무에서도 일할 기회가 생긴다면 노려보겠습니다.

## 직장을 선택하는 기준이 있나요?

네 저는 개발자로서 '개인의 노력만으로는 경험하기 힘든 기술적 깊이를 가진 곳인가'와 문제의 본질 기술에 관해 깊이 있는 고민을 할 수 있는 환경인가' 라는 기준을 가지고 직장을 선택하고 있습니다.

혼자서 아무리 열심히 공부해도, 실제로 수천만 명의 트래픽이 있는 환경에서 발생하는 데이터 일관성 문제나 아키텍처 설계 등을 경험하기는 어려울 것입니다. 그래서 저는 개발자로서 이러한 문제들을 직접 마주할 수 있고, 해결하며 개발자로서 저의 한계를 넓힐 수 있는 곳인지를 고려했습니다.

또한, 단순하게 기능 개발에만 몰두하는 것이 아닌, "왜 이 기술을 써야 하죠?", "왜 이 아키텍처를 사용해야 하죠"와 같이 기술의 본질적인 부분에 대해 고민해볼 수 있는 문화가 있는 곳을 선호했습니다. 소프트웨어 개발의 복잡성을 한번에 해결해주는 은탄환은 없다. 라는 말이 있듯이, 개발자는 끊임없이 더 나은 구조에 대해 고민해야 한다고 생각합니다. 그래서 이러한 환경이 갖추어져야 개발자와 회사 모두 성장할 수 있다고 생각합니다.

카카오는 실제로 수천만의 트래픽을 갖고있고, 코드 리뷰와 기술 블로그를 통해 끊임없이 본질을 공유하는 문화를 가지고 있기에 제 기준에  가장 부합하는 회사라 확신했습니다.

---

## 직무 선택 이유와 준비 방법

저는 Server와 Infra 직무를 가장 선호합니다. 
그 이유는 제가 그동안 개발해왔던 경험과 가장 맞닿아 있고, 대규모 트래픽 등을 경험하며 제가 가장 성장하고 싶은 분야이기 때문입니다.

저는 직접 제 서비스를 운영하며, Backend와 인프라 개발을 담당했습니다. Backend 코드를 작성하며, 코드의 유지보수성과 확장성을 위해 클린아키텍처와 같은 개념을 학습하고, 실제 코드에 적용해보며 비즈니스 로직을 분리하고, Repository 코드의 의존성을 제거하는 등 아키텍처에 대해 많이 고민해보았습니다.

또한 인프라적으로도 비용 절감을 위해 AWS에 CI/CD 파이프라인을 직접 구축하여 사용해 보았습니다. 또한 서비스 장애에 대응하기 위해, ELK 스택을 도입하여 실시간으로 로그를 모니터링하는 인프라를 구축해보기도 하였고, 이를 활용하여 응답속도가 느린 API를 분석하여 Redis 캐싱을 적용하고 응답속도를 개선해보기도 하였습니다. 

## 지원 직무에서 본인이 잘 할 수 있다고 생각하는 이유

먼저, 서버 직무의 개발자에게 가장 중요한 점은 아키텍처 설계라고 생각합니다. 서버 개발자는 비즈니스 로직을 잘 설계하여 가치를 만들어야 합니다. 또한, 핵심 비즈니스 로직이 외부에 의존하지 않도록 설계하여, 변화에 유연하게 대응할 수 있어야 합니다. 저는 이런 목적을 달성하기 위해, 클린아키텍처, 도메인 주도 개발 등의 개념을 학습했고, 실제 프로젝트에 의존성 역전이나 의존성 주입 등의 개념을 적용할 줄 압니다. 그렇기 때문에 서버 직무의 설계를 잘 수행할 수 있을것이라 생각합니다.

다음으로 인프라 직무는, 코드 외적으로 다양한 요구사항을 만족시켜야 합니다. 예를 들면, api의 응답 속도가 될 수도 있고 대규모 트래픽을 감당하는 방법이 될 수도 있습니다. 저는 이런 다양한 문제들을 마주했을 때, 문제를 피하지 않고 기술 스택을 배우고 프로젝트에 적용하며 문제를 해결한 다양한 경험이 있습니다. 이러한 경험은 인프라 직무에서 일을 할 때에도 중요한 역량이 될 것입니다.


## 직무 수행 시 가장 중요하게 생각하는 역량

저는 책임감과 의사소통 역량이라고 생각합니다.
먼저, 백엔드 개발자라면 어떠한 어려운 상황을 마주하거나 어려운 요구사항이 들어와도 문제를 피하거나, 맡은 일에 책임을 피하는 일이 있어서는 안됩니다. 맡은 일에 항상 책임을 갖고 주도적인 학습, 혹은 팀과의 소통을 통해 문제를 해결하는 것이 가장 중요합니다.

또한, 다양한 사용자 요구사항또는 시스템적인 요구사항을 기술로 풀어가야 하므로, 의사소통 역량 또한 필수입니다. 필요한 것을 빠르게 캐치하고 효율적으로 소통하여 업무의 생산성을 높일 수 있습니다.


## 직무수행에 필요한 역량과 목표를 구체화
---

## 포부
## 입사 후 1년 내 이루고 싶은 목표

입사 후 1년 동안의 목표는, 팀원들, 혹은 사람들이 신뢰하고 일을 맡길 수 있는 동료가 되는것이 목표입니다.

먼저, 초반에는 팀의 도메인 지식과 컨벤션을 빠르게 흡수하는 데 집중하겠습니다. 예를 글면 이 팀에서 왜 Redis를 사용했는지, 왜 Kafka 파티션을 이렇게 구성했는지 등 선배님들이 설계한 아키텍처와 코드의 히스토리를 빠르게 이해하겠습니다.

그 후에는 제가 공부했던 Redis 캐싱 전략이나, DB 쿼리 튜닝 지식 등을 활용해, 작은 성능 이슈부터 실질적으로 개선해보는 경험을 쌓겠습니다.

이런 과정들을 거쳐 1년 후에는, 이러한 트래픽 처리 문제는 민관님에게 맡겨도 돼. 혹은 이 기능 개발은 민관님이 할 수 있어. 와 같이 팀원들이 신뢰하고 일을 맡길 수 있는 동료가 되고 싶습니다.

## 입사 5년 후 모습ㅡㅡ

저는 5년 후, 어떠한 시스템적인 혹은 사용자들의 요구사항이 들어와도 꾸준한 공부를 통해 폭넓은 기술스택으로 해결하는 그런 개발자가 되고 싶습니다.

저는 개발자로서 사용자, 혹은 시스템적인 요구사항을 가장 중요하게 생각합니다. 이러한 요구사항을 해결해 나아가며 개발자가 가치를 만든다고 생각하기 때문입니다.

소프트웨어 개발의 복잡성을 한번에 해결해주는 은탄환은 없다 라는 말이 있듯이, 개발을 할수록 부족한 부분이 보이고 더 나은 구조에 대해 끊임없이 고민하게 되는것 같습니다. 그래서 개발자에게는 경험과 꾸준한 공부가 필수적이라 생각합니다. 그래서 저는 카카오와 같은 국내 최고의 IT 기업에서, 다양한 문제들을 직접 마주하고 해결하며, 끊임없이 공부하여 어떠한 요구사항이 들어와도 폭넓은 기술스택으로 해결해내는 그러한 개발자가 되고 싶습니다.

## 유연하고 자유로운 조직문화와 잘 맞나요?

네 저는 유연하고 자유로운 조직문화가 주도적으로 학습하고, 기술적으로 성장하고 싶은 사람에게 가장 좋은 기회를 제공한다고 생각합니다.
저는 스타트업에서 인턴을 했던 경험이 있는데, 그 곳도 수직적이지 않고 수평적인 문화를 가지고 있었습니다.

그래서 저는 서비스를 개발하면서, 더 이상 사용하지 않는 레거시 코드 혹은 DB 쿼리를 개선할 수 있는 부분을 발견하면 정리해두고, 어떠한 방식으로 개선할 수 있는지, 그리고 개선하면 어떤 기대효과가 있을지 등을 확실히 정리해서 CTO 분과 공유하고, 실제 서비스 내에서의 개선까지 이루었던 경험이 있습니다.

그래서 저는 저를 유연하고 자유로운 조직문화 내에서 끊임없이 성장하고 회사에 기여할 수 있는 사람이라고 생각합니다. 

당시 프로젝트에서 npm의 sleep이라는 패키지를 사용하고 있었습니다. 이 라이브러리는 C언어를 기반으로 스레드 자체를 sleep 시키게 해주는 라이브러리입니다. 당시 크롤러에서 이 코드를 사용하고 있었는데, 싱글 스레드인 javascript의 스레드가 멈춰버리므로 가급적 사용하지 않는 것이 좋습니다. 그래서 비동기 방식으로 sleep을 구현해서 사용하도록 제안했었습니다.

## 관습을 따르는편? 새로운것을 추구하는 편?

저는 관습을 존중하되, 명확한 근거가 있을 때는 새로운 것을 제안하는 스타일입니다.
저는 소프트웨어 개발에 정답은 없다고 생각합니다. 팀이 사용하는 레거시나 컨벤션은 그 당시에 생긴 이유가 있을 것이고, 또 변경하기 위해 필요한 비용도 크기 때문에 존중해야 한다고 생각합니다. 하지만 기존의 컨벤션이 팀의 생산성을 저해한다거나, 객관적으로 봤을 때 신기술을 도입했을 때의 얻는 것이 전환 비용보다 크다는 근거가 마련된다면, 새로운 것을 추구해야 합니다. 예를 들어, 서비스 규모가 너무 커져 MSA를 도입해야 한다던가, 배포 파이프라인 관리가 어려워 gitops 방식의 배포를 하면 배포 관리 비용이 준다던가 이런 상황을 잘 캐치해서 새로운것을 추구하는 것이 개발자에게 필요한 역량이라 생각합니다.

## 카카오와 본인이 추구하는 가치 중 일치하는 점

저는 단순히 기능을 만드는 것을 넘어, 왜 이렇게 해야하지? 이게 최선인가? 를 끊임없이 질문하며 더 나은 것을 추구하는 사고방식이 가장 일치한다고 생각합니다. 

카카오는 전 국민이 사용하는 서비스인 만큼, 남들이 사용하는 기술을 그대로 가져다 쓰는 것만으로는 해결할 수 없는 문제들이 많다고 생각합니다. 문제가 발생했을 때, 문제를 끊임없이 파고들며 그 과정에서 더 나은 답을 찾아가는 과정이 필수적일 것입니다.

저는 항상 공부를 할 때 이런 자세를 유지합니다.

사용자에게 필요한 문제를 해결하는것




## 본인이 생각하는 일의 의미

개발자로서 저는 일이란, 성장 과정이자 자아실현의 장이라 생각합니다.

기술과 요규사항은 정말 빠르게 변하기 때문에, 저의 분야에서 끊임없이 공부하고, 시야를 넓혀야 한다고 생각합니다. 

그래서 저는 이런 과정에서 재미를 찾습니다. 어제와 달라진 코드에서 성장하는 것을 느끼고, 그 과정을 즐거움으로 인식하여 성장이 자아실현으로까지 이어질 수 있는것이 일이라고 생각합니다.

제가 개발을 하면서 끊임없이 왜라고 질문하며 깊이 공부하는 것도, 일을 이러한 성장의 발판으로 삼고 싶기 때문입니다.

그리고 제가 개발한 기술이 사용자에게 가치를 제공하여 보람을 느끼는 것으로 이어지는 것까지 엔지니어로서 느낄 수 있는 일의 보람이라고 생각합니다.

## 상사가 부당한 지시를 했을경우?

먼저, 상사는 저와 다른 배경지식을 가지고 있고, 업무적인 부분에서 저보다 많은 것을 알고 있을 것입니다. 그러므로, 먼저 상사가 한 말씀이 제가 이해한것과 맞는지 다시 한번 확인하고 정리하겠습니다.

그 후에는 두가지 경우로 나누어 생각해볼 수 있을것 같습니다. 먼저, 법적으로 문제가 있는 지시일 경우입니다. 이 경우에는 지시에 따르지 않을 것입니다. 회사 내부의 감사 채널을 통해 이러한 상황을 공유하겠습니다.

그 다음으로는 법적인 문제가 없는 경우입니다. 이 경우는, 같은 목적을 달성할 수 있는 더 나은 방안을 찾아보겠습니다. 그 과정에서 팀장 등 차상급자에게 조언을 구하거나 하는 식으로 더 나은 방법을 모색하겠습니다.

## 본인의 업무 스타일과 강점을 구체적으로

저는 맡은 일에 책임감을 다하고, 해결하기 어려운 문제를 만나도 피하지 않고, 직접 해결하며 성장하는 강점을 가지고 있습니다.


---
# 회사
## 회사 내 서비스 중 자주 사용하는 것과 이유

오픈채팅

카카오 서비스 중 채팅 기능을 제외하고, 제가 가장 많이 사용하는 것은 카카오 맵 서비스입니다. 

## 서비스 개선하고 싶은 점

제가 카카오톡을 사용하면서 항상 불편했던 부분이 있습니다.
모바일과 PC 모두에서, 채팅을 검색할 때 엄청 오래전의 채팅을 검색하면 프로세스가 종료되어 버리는 현상입니다.
그래서 이러한 현상이 왜 일어날까에 대해 생각해보았습니다.
첫번째로 짐작가는 원인은, 너무 예전의 데이터를 검색하려다 보니 Query가 너무 느려서 timeout이 나고 뻗어버리는 경우.
두번째로 짐작가는 원인은 최신 채팅과 옛날 채팅 사이의 모든 대화 내용을 가지고 오려다 보니, 데이터가 너무 커서 프로세스가 할당받은 자원을 초과하고 종료돼버리는 경우입니다.
그래서 저는 작업 관리자를 통해, 이러한 검색을 했을 때 메모리 사용량이 어떻게 변하는지 확인해보았습니다. 그 결과, 오래전 채팅을 검색할 때, RAM 사용량이 270MB 정도에서 1GB까지 증가하고, 1GB가 넘으면 얼마 안 가 멈춰버리는 것을 발견했습니다.

그래서 저는 두번째 이유가 원인일 것이라 생각했습니다. 이 부분을 개선하기 위해선, 검색 api에 요청 했을 때 너무 큰 데이터라면 해당 위치의 채팅과 그 근처의 채팅만 전송하고, 무한 스크롤 방식으로 나머지 채팅을 로딩하는 방식을 생각해볼 수 있었습니다. 

물론, 실제로는 다른 원인일 수도 있고 해결 방법도 쉽지 않을 수 있지만, 카카오 서비스를 이용하면서 이 부분을 꼭 개선해보고 싶었습니다.


## 본인이 회사에 들어와서 새롭게 시도하고 싶은 것

최근 카카오에서 Kanana AI를 출시하기도 하는 등, AI를 활용하여 가치를 만드는 데에 집중하고 있는 것으로 알고 있습니다.

현재 카카오톡 채팅방 내의 검색은, 단순한 텍스트 매칭으로 이루어지는 것으로 알고 있습니다. 저는 RAG와 비슷한 원리로 채팅을 벡터화하여 저장하고, 사용자가 검색창에 지난달 강남역에서 점심 먹은게 뭐였지? 라는 식의 검색을 하면 해당 채팅을 찾아주는 그러한 검색 기능을 생각해봤습니다.

물론 이러한 기능을 구현하려면 이 기능이 가져올 '트래픽 부하'와 '비용'에 대한 고민이 가장 큽니다. 그래서 모든 메시지 저장이 아니라 정보성으로 가치가 있는 데이터 위주로 저장하거나  kafka와 같은 것을 사용해 사용자가 채팅을 보내는 속도가 느려지지 않도록 비동기를 고려하여 개발할 것입니다.

스마트 알림 요약

특정 시간 후 사라지는 단톡방

## 최근 본 회사 뉴스 -> 어떻게 생각하는지

(https://www.digitaltoday.co.kr/news/articleView.html?idxno=607587)
가장 최근에 본 뉴스는, 카카오가 일부 계열사를 정리하면서 카카오 본사가 "카카오톡, 광고, AI"를 핵심 축으로 사업 구조를 개편한다는 뉴스였습니다.
저는 이 뉴스를 통해, 카카오가 선택과 집중을 통해 미래 성장 동력인 기술에 집중한다고 생각했습니다.
(https://www.opinionnews.co.kr/news/articleView.html?idxno=128374)
카카오 뱅크가 금융권 최초로 AI와의 대화를 통해 송금할 수 있는 기능
이 기능은 저도 상상만 했던 기능인데, 카카오에서 실제로 출시한다 해서 깜짝 놀랐습니다. 이러한 기능을 위해서는 보안문제나, 오송금 문제 등등 고려할 부분이 많을 것입니다.
저는 카카오의 왜라고 끊임없이 질문을 던지는 문화 덕분에 다른 어떠한 서비스 보다 빠르게 이 기능을 출시할 수 있었다고 생각합니다. 

## 최근 업데이트를 어떻게 생각하는지?

네 사실 최근의 업데이트로 인해, 많은 비판의 여론이 있는 것으로 알고 있습니다.
사실 저는 바뀐 업데이트로 크게 불편함을 느끼지는 못했습니다. 약간 불편했던건 생일인 친구를 한눈에 보지 못하는것 정도였습니다.
그리고 최근에 신기한 뉴스를 접했는데, 업데이트에 반발하는 이론이 나왔지만 카카오의 성과를 증명하는 체류시간 등 다양한 지표는 오히려 증가했다는 것이었습니다. 

그래서 업데이트 자체는 성과가 있으므로 오히려 좋은 업데이트였다 라고 생각을 합니다. 하지만 또 불편하게 느끼는 분들이 많으므로, 이러한 급격한 변화가 있는 업데이트를 할 때는 한번에 적용하기 보다는, 설정에서 유저가 메인 화면의 구성을 선택할 수 있도록 선택지를 줘서 거부감을 없애고, 점진적으로 업데이트 하는 방식도 좋을 것 같다고 생각했습니다.


## 카카오 숏폼

송금하기와 연동하여 후원개념
카카오 선물하기나 쇼핑과 연계하여 시너지 효과

접근성이 아쉬움
이미 큰 기능들이 UI 차지하고 있어서 배치가 어려움
## 경쟁사와의 차별점

카카오가 갖춰놓은 페이, 뱅크, 채팅 서비스 등이 유기적으로 작동하는 인프라가 가장 큰 차별점이라 생각합니다.

경쟁사 중 하나인 네이버와 비교했을 때, 카카오는 관계 중심의 서비스라는 점이 큰 차별점이라고 생각합니다.

카카오가 하고 있는 서비스가 많아서, 경쟁사에 관한것도 다양하게 나누어 생각해볼수 있을 것 같습니다. 먼저 쇼핑과 페이 서비스의 경우에는 네이버와의 경쟁관계를 생각해볼 수 있을 것입니다. 네이버 쇼핑에서 뭔가를 선물하거나 하기 위해선 상대의 개인정보를 입력하거나 해야합니다. 하지만 카카오 서비스는 관계 기반이기 때문에 그런 귀찮은 과정 없이 선물하기, 송금, 이모티콘 등 편리하게 다양한 기능을 사용할 수 있습니다. 

또한 채팅과 관련해서는 라인과 WhatsApp같은 것을 생각해볼 수 있습니다. 저는 교환학생 시절 WhatsApp을 사용했었습니다. 채팅앱 자체로는 나쁘지 않았지만 아무래도 생일날 선물하기와 같은 기능을 사용할 수 없고, 친구들과 밥을 먹고도 간편하게 정산할 수 없다는 점이 매우 불편했습니다. 이렇게 다양한 서비스들과 통합해서 채팅앱을 사용할 수 있다는 것은 카카오만의 장점이라고 생각합니다. 라인은 카카오와 비슷하게 페이나 이런 서비스를 제공하긴 하지만, 대한민국에 집중한 서비스는 아니다보니, 카카오처럼 한 국가의 인증 서비스를 책임지고, 편하게 페이 시스템을 이용할 수 있는 서비스는 아니기에 많이 부족하다고 생각합니다.
## 회사의 미션/비전/이슈/최근사업 변경 사항을 숙지 후 답변과 연결

---
# 협업
## 팀갈등 경험이 있나요?

팀적으로 정말 싸우거나 한다는 큰 갈등은 없었지만, 의사결정 과정에서 갈등이 있었던 적은 있습니다.

제가 클린아키텍처 개념을 통해 리팩토링을 진행하려 할 때, 리팩토링 기간 동안 개발 일정이 밀리게 되고, 또 현재 코드로 서비스가 잘 운영되고 있는데 굳이 리팩토링을 해야 하나와 같은 반대 의견도 있었습니다.
저는 당시 직접 백엔드 개발을 하면서 이런 리팩토링의 필요성을 직접 실감하고 있었기에, 근거를 들어 팀원들을 설득해 보기로 했습니다.
먼저, 그 기간동안 신규 기능 개발을 할 수 없는 문제의 경우는 당장 필요한 기능 개발을 끝내두고, 2주라는 기간을 잡고 그 기간 내에 완벽히 작업을 끝내두겠다 했습니다.
또한 클린아키텍처의 필요성에 대해 현재 코드를 수정할 때 어떤 의존성 문제들이 있고, 의존성 역전 개념을 적용하고, 비즈니스 로직을 보호한다면 더 유지보수성이 좋아질 것이다 라는 내용을 설명하였습니다.
이러한 과정을 거친 후에 팀원들의 동의도 얻어 성공적으로 리팩토링을 마칠수 있었습니다. 

## 업무 중 잘 안맞는 사람을 만난다면?

팀으로 일 하다보면 안맞는 사람이 있는 것은 자연스러운 일이라 생각합니다.

안맞는 다는 것을, 성격이 안맞는 것과 업무와 관련해서 안맞는 것을 나누어 생각해볼 수 있을 것 같습니다.

먼저 성격적인 차이인 경우, 이해하고 배려해야 한다고 생각합니다. 저도 다양한 팀 프로젝트를 진행해보고, 외국인 친구들과 협업하기도 하고 특수학교에서 근무하기도 하면서 정말 다양한 사람들을 봐왔고 또 소통해봤습니다. 이러한 경험을 통해, 나와 다른 배경을 가진 사람을 '틀림'이 아닌 '다름'으로 받아들이고, 인내심을 갖고 경청하는 태도를 몸에 익혔습니다. 따라서 성격적인 차이는 충분히 소통과 배려로 맞춰나갈 자신이 있습니다.

업무적인 차이인 경우, 충분한 의사소통을 통해 의견을 조율해야 한다고 생각합니다. 각자의 방식을 고수해도 업무에 지장이 없다면 그냥 진행하면 되겠지만, 업무에 영향이 있을 경우 이를 조율하는 과정이 필요할 것입니다. 직장이라는 곳에서, 업무방식이 맞지 않는 사람이어도 모두 팀의 성과를 위해 일한다는 것은 변하지 않는 사실이라 생각합니다. 기본적으로 팀의 컨벤션, 관습을 따르고 따로 결정해야 하는 사안은 의사소통을 통해 서로의 방식의 장단점을 비교하고 더 효율적인 방식을 결정하여 따르겠습니다.

## 개발할 때 커뮤니케이션을 어떤 식으로 하는지

저는 커뮤니케이션이 필요할 때마다 바로바로 공유를 한다면, 팀원의 집중이나 업무의 몰입도가 깨질 수 있다고 생각합니다. 그래서 저는 개발할 때 커뮤니케이션이 필요한 내용이 생기면 기록합니다. 그리고 회의 시간이나 업무가 끝나서 이런것들을 공유할 수 있는 시간이라고 판단될 때 정리해 뒀던 내용에 관해 커뮤니케이션을 나눕니다.
그리고 여유가 된다면, 내용을 최대한 이해하기 쉽게 전달하기 위한 예시나 이미지 등을 준비합니다. 개발자마다 사용하는 기술 스택이 다르기도 하고, 또 복잡한 기술을 다루는 경우 저와 커뮤니케이션 하는 모든 사람이 그 내용을 안다고 생각하면 안됩니다. 그래서 가급적 서로 이해가 쉽도록 내용을 준비해서 공유하는걸 좋아합니다.

## 어떤 동료와 일할때 시너지가 나는지

저는 본인 업무에 책임감과 흥미를 가지고, 서로 동기부여가 되는 동료와 일할 때 가장 시너지가 납니다.

저도 정말 다양하게 팀플을 해보았는데, 제가 사용한 기술 스택에 왜 그걸 사용하게 됐는지, 어떤 장단점이 있는지 관심을 가지고 또 본인이 사용한 기술 스택에 대해서도 근거를 설명해주는 팀원과 같이 개발을 진행한 적이 있습니다. 저는 이런 환경에서 정말 동기부여가 되고 또 개발자로서 성장하는 것을 느꼈습니다. 

반면 일에 책임감이 없어 동기부여가 되지 않는 상황도 있었습니다. 정해진 기간 내에 기능을 완료해두지 않아, 팀 전체의 생산성이 느려지고 참여도 자체가 좋지 않은 동료와 일을 할 때 가장 힘들었었습니다.

## 어떤식으로 동기부여를 받는 편이고, 이를 다른 이들에게 어떻게 전파하는지

저는 내가 하고 있는 것을 통해 어떤 것을 얻고 싶은지, 어떤 목표가 있는지를 설정할 때 가장 동기부여를 받는 것 같습니다. 
예를 들면, 이 API의 응답속도를 100ms 안쪽까지 개선해보자, 혹은 사용자가 불필요한 과정없이 스터디 투표를 할 수 있도록 하자와 같은 크고 작은 목표입니다.
이러한 목표가 생기면 개발 과정이 더 재밌어지고 동기부여도 많이 됩니다.

현재 제 About 서비스의 목표는 MSA 아키텍처를 바로 도입할 수 있을 정도의 아키텍처를 구성하는 것 입니다.

그래서 저는 동기부여가 잘 안되는 팀원을 만났을 때도, 이걸 통해 어떤 것을 얻어가고 싶은지 많이 물어보는 편입니다. 그리고 제가 그 목표를 도와줄 수 있다면, 가능한 업무를 만들어주거나 같이 고민해주는 방식으로 이런 동기부여를 전파하는 편입니다

## 팀원을 설득하려 하는데 설득이 잘 안된다면 어떻게 할 것인지?

제 주장을 무조건 관철하는 것보다는 검증, 승복의 단계를 거치겠습니다. 먼저, 객관적인 데이터, 혹은 예시를 들어 설득을 해보겠습니다.

하지만 이러한 방식으로도 설득이 되지 않는 경우가 있을 것입니다. 그렇다면 그때는 상대의 의견에 승복하고 따르겠습니다. 세상에 무조건 적으로 나쁜건 없다고 생각합니다. 오히려 이러한 갈등 상황이 팀의 생산성에 문제를 주게 될 것이라고 생각합니다. 각자의 방식을 고수하면서 컨벤션이 무너지고 팀 생산성이 저하되는 것보다는 최대한 팀에 도움이 되는 선택을 하고 싶습니다.

---
## 프로젝트 하면서 어려웠던 점, 해결해나갔던 점

## 프로젝트를 다시 설계한다면 어떤 점을 개선

---
# 1차 면접 복기
## DNS에서 IP 여러개 검색됐을때

기본적으로 DNS 라운드 로빈 방식에 의해 순서가 변경된 IP 목록을 받게 되며, 클라이언트는 일반적으로 리스트의 가장 첫번째 IP를 선택하여 접속을 시도합니다. 이런 방식으로 트래픽을 분산시키게 됩니다. 만약 특정 IP가 유효하지 않다면, 다음 순서의 IP로 접속을 시도하게 됩니다.

DNS 서버는 그냥 주소록일 뿐이라, 서버 A가 고장 났는지 살아있는지 모릅니다. 그래서 서버 A가 다운되어도 DNS는 계속해서 TTL 시간동안 접속 오류를 겪게 될 가능성이 있습니다. 
## Redis가 다운돼서 모든 트래픽을 DB가 받아야할때

1차 면접에서 이 질문을 받았을 때, 저는 대안적인 측면을 많이 얘기했었습니다. Redis를 kubernetes 같은 서비스를 통해 빠르게 복구한다거나 DB가 이 요청을 감당할 수 있게 수평적으로 확장한다거나 하는 방법들을 생각했습니다.
그런데, 면접이 끝나고 조금 더 생각해보니, 캐시의 장애는 큰 문제가 되지 않을 수 있지만, 이것이 DB에 감당 못할 트래픽을 줘서 DB 장애로 이어진다면 훨씬 큰 문제로 번질 수 있겠다 생각했습니다. 그래서 이런 DB의 트래픽이 폭주하는 상황을 막기 위해, Circuit Bereaker를 도입해 DB로의 접근을 제한하는 방식도 좋겠다 라고 생각했습니다.

## 네트워크 7계층
응용 -> 표현 -> 세션 -> 전송 -> 네트워크-> 데이터 -> 물리

5,6,7계층은 거의 함께 작동하는 것으로 알고 있습니다. 응용 계층에서 사용자가 JSON등 데이터를 보내면 HTTP 헤더가 붙습니다. 

그 후, 전송 계층에서, HTTP 메시지에 TCP 헤더를 붙힙니다. 목적지 서버의 몇번 포트로 갈 지, 데이터의 순서 이런것들을 결정합니다.

그 다음 네트워크 계층을 거치며 IP 헤더가 붙습니다. 

다음으로 데이터 링크 계층에서 패킷에 이더넷 헤더가 붙고, MAC 주소를 통해 물리적 장비를 식별합니다.

마지막으로 물리 계층에서 이 프레임이 0과 1의 비트로 전송이 됩니다.

## SSH, FTP
---
# 기술

## google 에 접속했을 때 에러가 발생한다. 어떤 이유가 있을 것 같은지 아는 만큼 설명해주세요.  

트래픽의 흐름으로 볼 때, 먼저 내 컴퓨터 상에서 네트워크 연결이나 사내 보안 정책 등을 확인해볼 것입니다.
그 다음으로는 DNS에 장애가 있을 수 있습니다. 

그 다음으로는 구글의 데이터 센터에 문제가 생겼거나, 로드밸런서가 트래픽 폭주를 감당하지 못하고 있을 수 있습니다.

만약 서버와 연결에는 문제가 없다면, 논리적인 문제로 에러가 날 수도 있습니다. URL경로가 잘못되었다면 404에러를 보게 될것이고, 구글 내부의 애플리케이션 로직 에러나 타임아웃 문제라면 500번대 에러를 보게 될 것입니다.

google은 내부적으로 수많은 microservice들로 이루어져 있을 것입니다. 

## TCP, UDP 차이를 설명해주세요

TCP는 신뢰성 있는 연결을 보장합니다. 3way handshake 과정을 통해 서버와 연결됩니다. 데이터 순서를 보장하고, 패킷이 유실되면 재전송을 요청하며, 네트워크 상태에 따라 전송속도를 조절하는 흐름제어와 혼잡 제어 기능도 가지고 있습니다.

TCP 연결은 비용이 비쌉니다. 그래서 HTTP/1.0에선 요청이 끝나면 연결을 끊었지만, HTTP/1.1이후로는 연결을 유지합니다. Nginx와 같은 웹서버에서 timeout 기본값을 설정합니다. 혹은 요청을 N번 처리했으면 끊는다도 정의할 수 있습니다. 

반면 UDP는 신뢰성 있는 연결을 보장하지는 않지만 속도와 효율성을 중시합니다. 별도의 연결 수립 과정 없이, 데이터를 받는 쪽의 상태를 확인하지 않고 일방적으로 전송합니다. 재전송이나 순서보장을 하지 않아 유실 가능성이 있지만, 약간의 끊김이 있어도 실시간성이 중요한 스트리밍과 같은 곳에 사용합니다.
체크섬을 통해 비트가 깨졌는지 정도는 확인을 합니다. 대신 잘못되면 재전송 요청 없이 바로 버립니다.

## 카산드라DB 몽고디비 비교

몽고디비는 Master Slave 구조로 되어있어, 쓰기는 오직 하나의 Master노드에서 처리하므로, 쓰기 트래픽이 폭증하면 병목될 수 있습니다.
join을 어느정도 지원합니다.

반면 카산드라DB는 모든 노드가 읽기/쓰기를 처리하기 때문에 무한한 수평적 확장이 가능합니다. 가용성에 초점이 맞춰져 있습니다.
쿼리에 맞게 테이블을 설계해야 하고, join이 불가능합니다.

## JPA의 open session in view

요청이 들어오면 DB 커넥션을 잡고 ,응답이 나갈 때까지 이를 유지하는 방식입니다.
트래픽이 많은 프로덕션 방식에서는, 커넥션 풀 고갈 문제로 이어질 수 있기 때문에 끄는게 좋습니다.
이를 끄게 되면, 지연 로딩 문제가 발생합니다.
이를 해결하기 위해, join fetch와 같은 방식을 사용하여 entity를 미리 다 가져옵니다.

### JPA의 EAGER LAZY 조금 더 알아보기

연관 관계에 있는 다른 엔티티를 언제, 어떻게 데이터베이스에서 가져올 것인가를 결정하는 설정

EAGER: 엔티티를 조회하는 시점에 연관된 엔티티까지 즉시 데이터베이스에서 조히하여 영속성 컨텍스트에 올리는 방식

LAZY: 엔티티를 조회하는 시점에는 연관된 엔티티를 가져오지 않고, 실제 해당 데이터에 접근할 때 별도의 쿼리를 날려 가져옴.

EAGER로 설정해있을 때, 단일 select 쿼리를 사용하면, 연관된 엔티티가 비어있을 경우 JPA가 자동으로 반복문으로 쿼리를 날려 n+1 문제가 일어나도록 되어있습니다. 그러므로 실무에서는 EAGER를 사용하지 않고 LAZY로 사용해야 합니다.
LAZY를 사용하면 개발자가 제어할 수 있습니다. 필요할 때만 조회하게 됨

## docker 파일 작성방법은?

Dockerfile은 컨테이너를 생성하기 위한 설계도 입니다. 저는 보통 빌드 속도와, 이미지 경량화를 우선하여 작성합니다.

1. 베이스 이미지를 선정합니다. FROM 명령어로, OS나 런타임을 결정합니다. Alpine이나 Slim 버전을 사용하면 불필요한 패키지가 없어 이미지 크기를 최소화할 수 있습니다.
2. 그 후, COPY와 RUN 명령어를 통해, 의존성을 설치합니다. 소스 코드를 복사하기 전에 package.json이나 build.gradle을 COPY하고 RUN 하여 설치하면, Docker가 레이어 단위로 캐싱을 하기 때문에, 의존성 설치 단계를 캐시를 사용해 빌드 속도를 높일 수 있습니다.
3. 마지막으로 ENTRYPOINT/CMD를 사용하여 컨테이너가 시작될 때 실행할 명령어를 정의합니다. ENTRYPOINT로 실행 파일을 지정하고, CMD로 기본 인자를 넘겨줍니다.
이 과정에서 멀티 스테이지 빌드를 사용하여, 빌드 도구가 포함된 무거운 이미지를 빌드하는 과정을 수행하고, 결과물인 JAR 파일만 복사하여 2단계에서 실행하면 최종 결과물 이미지 크기를 획기적으로 줄일 수 있습니다.

도커 엔진이 캐싱을 합니다. 빌드하는 머신의 로컬 디스크에 저장을 합니다. 도커 데몬이 각 명령을 실행하기 전에 이전에 빌드했던 거랑 같은지 확인합니다. 하나가 깨지면 그 이후는 전부 다시 실행합니다.

멀티스테이지로 빌드하면, 마지막 결과만 이미지가 됩니다. COPY --from=build와 같은 명령으로 빌드 결과만 가져올 수 있습니다.

gradle과 maven은 의존성을 관리하고 build해줍니다. 컴파일이나 테스트도 수행합니다.

## Nodejs 의 동작 원리를 설명해주세요.

Node.js란 Javascript를 브라우저 밖에서도 실행될 수 있게 하는 Javascript 런타임입니다.

멀티스레드는 스레드 풀이 늘어날수록 CPU를 소모하고, 요청이 적다면 노는 스레드가 생기는 등 문제가 발생한다. -> Node.js는 싱글스레드 논블로킹 모델로 구성되어 있다. 하나의 스레드로 동작하지만 비동기 I/O작업을 통해 요청들이 서로 블로킹 하지는 않는다.

Node.js는 클러스터링을 통해 프로세스를 fork 하여 멀티스레드처럼 사용될 수 있습니다. -> 확정성이 용이

하지만 Node.js가 완전한 싱글스레드는 아닙니다. 일부 Blocking 작업들은 libuv의 스레드 풀에서 수행됩니다. 

Node.js는 내부적으로 다음으로 구성되어 있습니다.
- Node.js Core Library
- Node.js Bindings
- V8 Engine - javascript -> c++
- libuv

콜백함수들은 libuv 내에 위치한 이벤트 루프에서 관리 및 처리됩니다. 이벤트 루프는 여러 페이즈를 갖고 있고, 각 페이즈들은 각자의 큐를 갖습니다. 

논블로킹 I/O모델은 Input과 Output이 관련된 작업 등의 블로킹 작업들은 백그라운드에서 수행하고, 이를 비동기 콜백함수로 이벤트 루프에 전달하는 것을 말합니다. 
I/O들은 OS커널 혹은 libuv의 스레드 풀에서 담당합니다.(이 스레드 풀은 멀티스레드로 이루어져 있습니다.) 작업이 완료되면 이벤트 루브에 콜백 함수로 등록됩니다. 

이벤트루프는 다음의 6 페이즈를 라운드 로빈 방식으로 순회합니다.
1. timers: setTimeout() 같은 timer함수들이 처리됩니다.
2. pending callbacks: 다음 루프 반복으로 연기된 I/O 완료 결과가 큐에 담깁니다. 
3. 패스
4. poll: I/O와 관련된 콜백을 실행합니다. poll 큐에 쌓인 콜백함수들을 한도가 넘지 않을 때까지 동기적으로 실행.
5. check: 이벤트루프가 poll 단계에서 작업을 수행한 뒤, poll 이벤트를 기다리지 않고 check 단계로 넘어가게 됩니다.
6. close callbacks: close 이벤트에 따른 콜백 실행

## Spring 동작 원리

MVC
- DispatcherServlet: 요청이 발생하면, 코드를 트리거 함.
- HandlerMapping: 요청을 바탕으로 어떤 controller를 실행할지 결정
- Model: Controller에서 View로 넘겨줄 객체가 저장되는 곳
- ViewResolver: view name을 바탕으로 View 객체를 결정

요청이 들어오면 DispatcherServlet이 받아서 HandlerMapping에게 객체를 넘기고, 호출해야할 Controller 메소드 정보를 얻는다.
DispatcherServlet이 HandlerAdapter 객체를 가져온다. HandlerAdapter 객체의 메소드를 실행한다.
Contoller는 비즈니스 로직을 처리하고, 그 결과를 뷰에 전달할 Model 객체에 저장한다.

제어의 역전 IOC를 지원한다. 컨트롤의 제어권이 프레임워크에 있다. 빈에 등록된 객체의 생명주기를 전부 프레임워크가 관리한다.
의존성 주입

AOP: 공통으로 사용하는 기능을 분리하여 관리

## n+1쿼리
학생 리스트가 있고, 각 학생이 여러 과목을 수강하고 있다. 
모든 학생과 학생들이 수강하는 과목 정보를 갖고 오고 싶다.
모든 학생 정보를 갖고 오는 쿼리 한개 + 각 학생별로 과목 정보를 가져오는 쿼리 -> n+1개

어떻게 해결?
- Join 사용
- 배치 쿼리 사용. IN (1,2,3,4) 같은 느낌으로

데이터베이스 쿼리가 너무 많아서 과부화. 네트워크 트래픽 증가. 성능 안좋아짐. 

JPA같은것을 사용할 때 이런 문제 마주할 수 있음. findAll 후 map으로 순회하며 각각 조회

EAGER 방식은 N+1 피할 수 있지만, join이 너무 큰 문제 발생 가능.

LAZY + fetch join이 정석
fetch join은 연관된 엔티티를 실제 객체 그래프까지 함께 가져오도록 강제하는 JPA전용 조인

## 카프카

**오픈소스 분산 이벤트 스트리밍 플랫폼**입니다
기본적으로 producer와 consumer가 특정 topic에 데이터를 넣고 소비하기 위해 사용합니다. 데이터가 지워지지 않는다는 특징과 대용량 데이터를 분산처리 한다는 장점 때문에 최근 MSA 사용과 맞물려 많이 사용하고 있습니다.

클러스터, 브로커, 토픽, 파티션, 세그먼트

- 클러스터: 여러대의 브로커로 구성된 시스템. 대량의 데이터를 처리하고, 여러 소비자와 생산자에게 메시지를 제공한다. 
- 브로커: kafka 시스템을 구성하는 개별 서버. 각 브로커는 토픽의 하나 이상의 파티션을 저장하고 관리한다. 이 파티션들에는 메시지 또는 레코드가 순차적으로 저장된다. 
  Producer로부터 데이터를 받아 저장하고, Consumer의 요청에 따라 저장된 데이터를 제공한다.
  브로커에는 리더와 팔로워가 있다. 리더는 모든 읽기 쓰기 작업을 처리하고, 팔로워는 리더의 데이터를 복제한다.
- 토픽: 메시지들의 특정 카테고리 또는 피드를 나타낸다. Producer가 데이터를 보내는 대상이고, Consumer가 데이터를 읽는 출처다. 
- 파티션: 하나의 토픽은 여러 개의 파티션을 갖는다. 이는 Kafka의 확장성과 병렬 처리 능력을 향상시킨다.
  각 파티션은 독립적으로 데이터를 저장하고, 여러 브로커에 걸쳐 분산될 수 있다. 
  각 파티션 내에서 메시지는 순차적으로 저장되며, 이 순서는 파티션 내에서 유지된다.
  시스템 부하가 증가하면, 파티션을 추가하여 처리 능력 확장이 가능하다. 

## Redis
데이터베이스, 캐시, 메시지브로커 등으로 사용됨
디스크가 아닌 메모리에서 데이터를 처리하기 때문에 매우 빠른 데이터 엑세스 속도를 제공

메모리에서 데이터 처리 + 메모리에서 처리된 데이터를 주기적으로 디스크에 동기화해 데이터 유실을 방지

스냅샷, AOF -> 주기적으로 디스크에 저장 + 모든 쓰기 작업을 기록하여 복구

Pub/Sub: 메시지 브로커 역할 수행. 실시간 소통 지원. 특정 채널에 메시지를 발행하면, 이를 구독한 모든 클라이언트가 해당 메시지를 실시간으로 수신하는 구조

메모리 효율적인 관리 필요
- TTL: 불필요한 데이터가 메모리 차지하지 않도록 관리
- 자주 사용되지 않는 데이터 삭제, LRU 알고리즘
- 압축

마스터-슬레이브 복제와 클러스터링으로 높은 가용성 제공하지만, 장애 발생시 데이터 유실 가능성 완전히 배제는 불가.

## Docker
애플리케이션을 쉽게 배포, 공유할 수 있도록 설계된 컨테이너 기반의 오픈소스 가상화 플랫폼.

기존에는 VM을 사용하여 하이퍼바이저 위에 Guest OS를 통째로 설치해야 했지만, Docker의 등장후에는 Docker 위에서 Host OS의 커널을 공유하며 더 가볍게 가상화가 가능해졌습니다.

Docker의 핵심 원리는 리눅스의 두가지 핵심 기능을 바탕으로 만들어졌습니다.
1. 네임스페이스: 격리
   컨테이너의 격리된 뷰를 제공하는 기술입니다. 각각의 컨테이너가 독립된 IP와 포트를 가진 것처럼 격리할 수 있습니다.
2. cgroups: 자원 제한
   컨테이너가 사용할 수 있는 시스템 자원을 제한하고 광리하는 기술입니다.

## 변수와 함수가 저장되는 위치

변수와 함수는 프로그램의 메모리 구조 안에서 정해진 영역에 저장됩니다.

운영체제는 프로세스에게 Code, Data, Stack, Heap 이렇게 네 가지 공간을 할당합니다.

저희가 작성한 코드는 Code 영역에 저장됩니다.

Data영역에는 전역변수와 정적변수가 저장됩니다. 이 변수들은 프로그램 시작부터 끝까지 유지됩니다.

Stack 영역에는 함수 내의 지역 변수와 매개변수가 저장됩니다.

Heap 영역에는 개발자가 코드를 통해 동적으로 할당하는 변수, 객체가 저장됩니다.

재귀함수가 너무 깊이 호출되면 Stack 영역이 가득 차서 프로그램이 비정상적으로 동료될 수도 있습니다.
Heap영역에 할당된 메모리는 사용 후 헤재되지 않으면 가용 메모리가 부족해질 수 있습니다. 가비지 컬렉터가 있긴 합니다.

## 개발 과정에서 가장 풀기 어러웠던 상황은 무었이였는지?

코드 레벨에서는 코드간의 의존성을 제거하는 문제였습니다.
인프라레벨에서는 한정된 인스턴스 자원을 효율적으로 활용하는 문제였습니다.

## 자바 언어의 특징과 객체 지향 설계
자바의 특징은 플랫폼 독립성입니다. JVM이라는 가상 머신 덕분에, 자바 코드는 JVM이 이해할 수 있는 바이트코드로 변환됩니다. JVM이 이 바이트 코드를 OS에 맞게 해석해줍니다.

또한 가비지 컬렉터가 메모리 누수같은걸 막아줍니다. 

또한 객체지향 언어입니다. 

객체지향 설계는 4가지 특징이 있습니다.
1. 캡슐화: 관련된 데이터와 기능을 하나의 캡슐로 묶습니다.
2. 상속: 부모 클래스의 필드와 메서드를 자식 클래스가 물려받아 재사용합니다.
3. 추상화: 객체들의 공통적인 특징을 뽑아내어 인터페이스나 추상 클래스로 정의하는 것입니다. 사용자는 어떻게 구현하는지 알 필요가 없습니다. 
4. 다형성: 오버라이딩이나 인터페이스 구현을 통해 실현됩니다. 부모 타입의 참조 변수가 자식 타입의 객체를 가리킬 수 있게 됩니다. -> 코드가 유연하고 확장 가능해집니다.

---
# 개발

## 왜 개발자를 선택했는지

저는 개발자로서, 사람들의 요구사항을 해결하며 필요로 하는것을 제공하고, 그 과정에서 끊임없이 공부하고 성장하는 것에 성취감과 재미를 느끼기 때문에 개발자를 선택했습니다.

처음 개발을 접한건 고등학교 2학년때, 빅데이터 전문가라는 직업을 알게 되면서 였습니다. 빅데이터 전문가가 되기 위해서는 프로그래밍 언어를 공부해야 한다는 얘기를 듣고 막연하게 C언어를 공부했습니다. 그렇게 대학에 진학했고, 웹 개발을 접했습니다. 처음에는 프론트엔드 개발로 시작하며 제가 개발한 것이 화면에 바로바로 뜨는게 재미있어 열심히 공부했습니다. 그리고 그 과정에서 보이지 않는 곳에서 비즈니스 로직을 처리하는 백엔드라는 분야를 알게되었고, 여러 서비스를 만들어보고 싶어 백엔드 개발 또한 시작했습니다. 여러 토이프로젝트를 하던 중, 제가 참여하던 대학생 스터디 동아리의 불편한점을 내 기술로 해결할 수 있지 않을까 생각했고, 그렇게 About 서비스를 제작하게 되었습니다. 이 과정에서 사람들의 다양한 요구사항을 듣고 이를 서비스로 구현하며, 재미와 성취감을 느꼈습니다. 그리고 이 과정에서 많은 트러블 이슈들을 해결하고, 인프라적인 것들까지 공부하며, 저의 개발자로서의 역량을 끌어올릴 수 있었습니다.

이렇게 개발에 관심을 가지고 그동안 진행해왔던 모든 과정이 너무 재미있었고, 또 개발자로서 꾸준히 성장하는 것이 보람차기 때문에 저는 앞으로도 계속 개발자를 할것입니다.

## **높은 러닝 커브를 증명할 수 있는 경험**

제가 서비스 운영 중 발생하는 에러에 대응하기 위해 ELK 스택을 학습하고, API 응답속도까지 이어서 Redis 캐싱까지 적용해본 경험을 소개해 드리고 싶습니다.

먼저, 서비스 운영 중 에러가 발생했을 때, Docker의 로그를 console에 들어가서 확인하는게 힘들어서, 이 부분의 개선 필요성을 느꼈습니다. 직접 DB에 저장하는 방식도 고려했지만, 이 과정에서 현업에서 어떤 기술을 사용하는지 알아보면서 ELK 스택에 대해 알게되었습니다.
로그 분석을 위한 추가적인 인프라를 구성하는 것은 운영중인 서비스에 영향을 주지는 않기 때문에 프로젝트에 바로 적용하며 학습했습니다. Log를 Elasticsearch로 바로 인덱싱 하기 위해 파일을 구성하는 방법과, 어떻게 웹 상에서 시각화 할 수 있는지를 빠르게 학습해서 인프라를 구축했습니다.

그런데, 제가 넉넉하지 않은 인스턴스에서 ELK 스택을 운영하다보니, LogStash와 ElasticSearch의 높은 메모리 사용량을 감당하지 못해 ELK 스택이 자주 다운되는 문제가 있었습니다. 저는 이를 해결하기 위해 조사했고, Filebeat라는 경량 수집기가 있다는 것을 알게 되었습니다. Logstash는 JVM상에서 동작하고 데이터 변환 기능을 강력하게 제공해서 메모리를 많이 사용하는데, 저는 로그 데이터 수집에 데이터 변환 기능이 많이 필요가 없기 때문에, 이를 즉시 Filebeat로 변환하여 메모리 사용량을 최적화 했습니다.

저는 이에 그치지 않고, 로그 데이터를 어떻게 활용할 수 있을지를 고민했습니다. 당시 저희 초기 페이지 렌더링이 느리다는 말이 있었는데, 응답속도가 느린 API를 분석해봐야겠다라고 생각했습니다. 바로 분석을 시작했고, 응답 속도를 줄이기 위해 Redis 캐싱을 사용해보고, 또 압축까지 적용하여 응답속도를 60%이상 개선까지 해보았습니다.

이렇게 저는 문제 상황을 피하지 않고 기술 스택을 빠르게 학습해서 적용하는 역량을 갖춰서 러닝 커브가 높다고 말씀드리고 싶습니다.


%% 저는 한번 개선해둔 것에 만족하지 않고, 더 나은 구조를 끊임없이 공부하기 때문에 러닝커브가 높다라고 말씀드리고 싶습니다.
대표적인 예시로 아키텍처에 관한 러닝커브를 말씀드리고 싶습니다.
코드를 운영하며 서비스 규모가 커지고 코드 양이 많아지자, 비즈니스 로직이 산재해 있어 코드를 수정하면 비즈니스 로직이 일치하지 않게 된다거나, 새로운 요구사항을 반영할 때, 수정해야 하는 코드가 너무 많아 수정이 어렵다거나 하는 문제를 마주했습니다. 그리고 이 시점부터 유지보수성을 높일 수 있는 코드 아키텍처에 관해 끊임없이 고민하기 시작했습니다.

처음에는 주위의 조언을 구해 클린아키텍처 개념을 학습했습니다. 이를 통해 코드를 controller, service, repository 등으로 분리하는 방법을 배웠고, 빠르게 직접 프로젝트에 적용까지 해보았습니다. 그렇게 구조가 확실히 개선되었지만, service 코드에서 repository에서 데이터베이스를 조회한 결과를 그대로 받아 사용하고 있었기에, 의존성이 제대로 제거되지 않아다는 느낌을 받았습니다.  %%



## AI, 트렌드 관련해서 생각이나 경험

먼저 저는 AI 활용 역량을 기르기 위해, 다양한 서비스에 LLM을 활용한 기능을 넣고 있습니다. 먼저, 대학교 해커톤에서 진행한 프로젝트에서, 도서관 프로그램 추천 기능을 LLM을 활용하여 구현하였습니다. 또한, 교환학생 시절 사용자의 상황에 맞는 운동 루틴 추천 기능을 구현하기 위해 GPT API를 사용했었습니다.

그리고 현재는 대학교 졸업 수업의 팀프로젝트로 저희 학교의 챗봇 서비스를 구현하고 있습니다. LLM의 할루시네이션 현상을 해결하기 위해 RAG를 구축하고, LLM 사용 비용을 줄이기 위해 LLM 캐싱에 관련한 논문을 읽고 프로젝트에 적용하여 비용을 줄이려는 시도도 해보고 있습니다. 

개발자는 AI 시대에 살아남기 위한 전략이 필요하다고 생각합니다. 이제 단순히 코드를 짜는 일은 사람보다 AI가 더 잘하는 수준까지 올라왔다고 생각합니다. 먼저, 꾸준한 공부는 여전히 계속 필요합니다. AI를 어떻게 활용할지, 어떻게 좋은 퀄리티의 답변을 얻을지는 결국 엔지니어의 역량에 달려있습니다. 해당 분야에 자세한 지식이 없다면 AI로 부터도 자세한 답변을 얻을 수 없습니다.
또한, AI가 대체할 수 없는 문제 정의와 설계 역량에 집중해야 합니다. AI는 어떻게 코드를 짤지는 알지만, 왜 이 기술을 써야 하는지 비즈니스 상황에 맞춰 판단하는것은 어렵고 또 인간이 결정해야 합니다. 그래서 이 상황에서 어떤 기술 스택을 사용할지 어떻게 아키텍처 구조를 설계할지와 같은 고차원적인 결정을 할 수 있는 개발자로 거듭나야 합니다.

---
# 인성
## 세상에서 가장 중요한 3가지가 무엇인지? 

신뢰, 본질, 사람

먼저, 신뢰입니다. 저는 신뢰가 모든 인간관계에서 가장 중요한 가치라고 생각합니다. 전문가로서는 본인의 분야에서 꾸준한 학습을 통해 신뢰를 얻어야 하고, 인간으로서는 원활한 의사소통으로 공동체 내에서 신뢰를 얻어야 좋은 관계를 많이 유지할 수 있다고 생각합니다.

둘째는 본질입니다. 세상은 빠르게 변하지만 본질은 변하지 않습니다. 예를 들면, 기술 스택은 변해도 클린아키텍처라는 설계는 변하지 않고, ~ 변하지 않습니다. 그래서 본질을 볼 줄 알아야 한다고 생각합니다.

셋째는 사람입니다. 아무리 뛰어난 성취도 혼자서는 의미가 없다고 생각합니다. 저의 성장은 주변 사람들과의 교류 속에서 이루어지고, 행복 또한 사람과의 관계에서 온다고 믿습니다. 타인을 존중하고, 제가 가진 것으로 누군가에게 도움이 될 때 삶의 진정한 의미가 완성된다고 생각합니다.

## 본질에 집중해본 경험

## 인생을 사는데 즐거움을 무엇으로 찾는지?

저는 자기개발을 통해, 어제의 나보다 조금 더 나아지는 과정을 통해 즐거움을 찾습니다.

예전에는 친구, 연인과 같은 다른 사람을 통해 즐거움을 찾으려 했습니다. 하지만 결국 인생을 잘 살아가기 위해서는 스스로에게서 즐거움을 찾아야 한다고 생각했습니다.

예를 들어, 러닝과 운동을 들 수 있습니다. 처음에는 3km도 뛰기 힘들었지만, 꾸준히 하다보면 4km 5km로 뛸 수 있는 거리가 늘어나게 됩니다. 그 외에도 어제보다 하나 더 공부한 것, 어제보다 운동을 통해 몸이 좋아진것 등등을 통해 조금씩 어제보다 나아지고, 스스로 정한 목표를 하나씩 달성하며 인생의 즐거움을 찾으려 하고 있습니다.

## 장단점

저의 장점은 어느 환경에나 적응하는 의사소통 역량입니다.

저의 단점은 거절을 잘 하지 못하는 것입니다.

## 성공한 프로젝트에 대해서 설명하시오.

대학생 모임 플랫폼을 말씀드리고 싶습니다.

## 실패했던 경험에 대해서 말씀해보세요. 어떤 경험이었는가?

개발:

인생:

## 큰 실수
개발: DB의 테이블 하나를 지워버린것 -> 

인생:


## 주변 친구들은 당신을 어떻게 생각하는가? 그리고 당신의 단점은 무엇인가?

주변 친구들은 저를 무던하고 든든한 친구라고 보는것 같습니다. 그래서 돌같다는 말도 조금 들어봤습니다. 제가 감정 기복이 크지 않고, 얘기를 들어주는걸 잘하고 입이 무거운 편이라 친구들이 고민을 쉽게 털어놓기도 하고, 좀 무던하고 믿을만하다 라고 생각하는 것 같습니다. 
팀프로젝트를 할 때도 사실 왠만한 상황에서는 감정적으로 대응하지 않고, 차분하게 근거를 들어 말해서 좀 원할하게 팀프로젝트를 진행하는 것 같습니다.

## 스트레스 해소

원인을 해결할 수 있는 프로젝트

원인을 해결할 수 없는 프로젝트

## 인생에서 가장 힘들었던 경험

특수학교라는 환경에 놓이게 됐을 때

## 츨퇴근

제가 현재는 회기역 쪽에서 거주하고 있어서 1시간 정도 출퇴근 시간이 소요됩니다. 만약 제가 합격하게 된다면, 회사와 조금 가깝고 출퇴근이 편한 야탑과 같은 곳으로 거주지를 옮길 생각이 있습니다.

## 장점과 단점

---
## 직무 구체적 로드맵

## 가장 최근에 읽은 논문

최근에 LLM 캐싱에 관심이 있어서, 논문을 선정하고 읽었습니다. 제목이 좀 길었는데 LLM애플리케이션을 빠르게하고 비용 절감할 수 있는 GPTCache라는 제목이었습니다.  Zilliz라는 벡터 데이터베이스 회사에서 발행되었고, 130회 정도 인용이 된 논문이라 신뢰성이 있다고 판단했습니다.


## 야근에 관한 생각
저는 스타트업에서 인턴을 했던 경험이 있습니다.
아무래도 요구사항이 많고, 빠른 스프린트 기간 내에 업무를 진행하려다 보니, 야근이 필수인 곳이었습니다. 

사실 야근이 너무 많이 하게 되면 체력적으로나 정신적으로 쉬운일은 아니라 생각합니다. 
그리고 개발자가 본인 일에 책임감이 있다면 야근은 피할 수 없는 일이라고 생각합니다. 예를 들면, 내가 개발한 기능의 배포가 있는 날이라면, 다른 일들보다 배포가 잘 됐는지 또 그 후에 무슨 추가적인 문제가 생기지 않는지 끝까지 확인해야 하고, 그러다 보면 야근도 하게 된다고 생각합니다.

저는 오히려 야근을 좀 즐기는 편이었습니다. 
저는 좀 긍정적인 부분을 많이 보려고 하는 편이라, 야근을 하면 회사에서 저녁도 먹고 급여도 좀 더받고 좋잖아? 이렇게 좀 생각을 했었던 것 같습니다.

## 애자일에 대해 자세히 설명해봐라

애자일은 변화에 대응하는 마인드셋 입니다.
작게 만들고, 빠르게 피드백을 받아 요구사항을 빠르게 해결하는걸 지향합니다.

애자일의 핵심은 빠른 피드백에 있다고 생각합니다. 

## 마지막으로 하고싶은말

## 평가하는 위치에서 직장에 속한 사람들을 자연인, 직장인, 동료인을 어떻게 평가할 것인가?

## 업무를 하다 지긋지긋할 정도로 힘든 상황은 어떻게 극복하는지

개발을 하다보면, 끊임없는 버그 때문에 잠도 제대로 못자고 그런 힘든 상황을 많이 마주하게 되는것 같습니다.

저는 이런 일을 작은 성취를 통해 극복하는 것 같습니다. 예를 들면 잠시 다른 것을 해서, 그걸 완료하여 보람을 느끼고 원래 문제로 돌아옵니다. 이렇게 하면 뇌도 좀 리프레쉬 되고 다시 문제를 해결해 볼 힘을 얻게 됩니다. 

혹은 운동이나 가벼운 산책 등으로 잠시 문제에서 벗어났다가 돌아오기도 합니다. 

문제를 잘게 쪼개어 진행도를 느끼며 작업하는 것도 도움이 되는것 같습니다.

## Webpack에서 Vite로의 전환과정
(https://tech.kakao.com/posts/770)


# 인재상

|                                                  |
| ------------------------------------------------ |
| **. 인재상**                                        |
| 1. 가보지 않은 길을 두려워하지 않는 사람 **(도전 의식)**             |
| 2. 무슨 일이든 본질만 남기고 처음부터 다시 생각하는 사람 **(분석력, 차분함)** |
| 3. 나보다 동료의 생각이 더 옳을 수 있다는 믿음을 가진 사람 **(신뢰)**     |
| 4. 스스로 몰입하고 주도적으로 일하는 사람 **(리더십, 목표 달성)**        |
| 5. 세상을 선하게 바꾸려고 노력하는 사람 **(성실함, 선함)**            |
