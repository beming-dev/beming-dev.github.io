---
thumbnail: default.jpg
slug: "/blog/codit/sql"
date: "2025-07-13"
title: "Bulk insert를 이용한 MySQL 쿼리 최적화"
categories:
  - mainCategory: "Area"
    subCategory: "codit"
---

코딧은 크롤링을 통해 다양한 뉴스, 법안, 회의록 데이터를 수집하고 있습니다.

또한 DB에 저장된 수천만 ~ 수억개의 데이터를 사용자들에게 효율적이고 빠르게, 그리고 다양한 방식으로 검색을 제공해야 합니다.

데이터베이스를 MySQL을 사용한다고 가정하면, MySQL만으로 충분한 성능의 기능을 제공할 수 있을까요?

# MySQL에서의 서비스 제공

MySQL에서 다양한 조건으로 빠른 검색을 제공하기 위해서는 아래와 같은 방법들을 생각해볼 수 있습니다

## 인덱스 설계

- 자주 조회되는 키를 기준으로 인덱스를 설계합니다.
- Full Text 인덱스를 추가하여 전문에서 검색이 용이하도록 합니다.
- 두개 이상의 인덱스를 묶어 복잡한 조건에서도 인덱스를 탈 수 있도록 합니다.

MySQL에서 인덱스를 해두는것과 해두지 않는것은 데이터의 크기가 클 수록 조회속도에서의 차이가 큽니다.

인덱스를 잘 설계하면 빠른 검색을 기대할 수 있지만, 검색 조건이 다양해질수록 제대로된 인덱스를 설계하기가 어려워집니다.

또한 인덱스는 읽기 속도를 높혀주지만, 나머지 연산(INSERT, UPDATE, DELETE)의 연산속도는 늦춥니다. 따라서 지속적으로 데이터를 쓰고 수정해야하는 크롤링 데이터에 너무 많은 인덱스를 걸어놓는건 성능에 좋지 않을겁니다.

## 데이터 분할, 샤딩

- 데이터를 년도별, 혹은 다른 기준으로 파티셔닝 해둘 수 있습니다.
- 애플리케이션에서 특정 shardId를 계산해 어떤 DB 인스턴스에 접근할지 결정할 수 있습니다.
- 프록시, 미들웨어에서 샤딩을 관리할 수 있습니다.
- MySQL 전용 샤딩 솔루션(Vitess 등)을 사용합니다.

위와같이 데이터를 분할, 샤딩하여 관리할 수도 있습니다.
하지만 여러 MySQL 인스턴스가 필요할 수 있고, 저희 서비스의 성격과 잘 맞지 않는 방식입니다.

# Elasticsearch 도입

MySQL만으로 풀텍스트 검색과 대용량 분산 처리를 모두 커버하기엔 한계가 있습니다. 특히 **다양한 언어 분석**, **실시간 색인**, **수평 확장**이 필요한 경우에는 Elasticsearch 도입을 고려해볼 수 있습니다.

## 어떤점이 좋을까?

먼저, ElasticSearch는 오픈소스입니다. 충분한 자원과 약간의 learning curve만 넘으면 누구나 사용할 수 있습니다.

문서 단위로 인덱스를 생성하고, 역색인 방식으로 빠른 검색을 제공합니다.
MySQL의 Full-Text는 문서 단위 검색에 제한이 있지만, ES는 토큰화, 형태소 분석 등 다양한 분석기를 제공합니다.

또한 자동으로 데이터를 샤딩하여 저장하고, 내부적으로 노드를 재배치 하는 작업도 진행합니다.
Master-Data 노드를 구분해 고가용성 및 장애 복구를 지원합니다.

## 고려해야 할 점은?

elasticsearch의 도입은 확실히 관리 리소스를 증가시킵니다.
DB에 있는 데이터를 elasticsearch에 인덱싱 해야하므로 데이터의 불일치, 누락이 발생할 수 있고 elasticsearch용 쿼리를 설계해야 하는 불편함이 있습니다.

Codit 서비스는 주로 크롤링한 데이터, api에서 받아온 데이터를 서빙합니다.
그러기 위해선 받아온 데이터를 DB에 저장하고, 서비스에서 사용하기 좋은 형태로 가공하는 과정이 필요합니다.

특히 크롤링 된 데이터는 완벽할 수 없습니다. 크롤링 된 데이터를 바로 사용한다면, 비즈니스 로직쪽에 DB에서 데이터를 가져와 전, 후처리 해주는 로직이 들어가게 됩니다.

그러나 이 부분을 elasticsearch에 indexing하는 과정에서 처리한다면 코드를 조금 더 깔끔하게 분리할 수 있습니다.

그렇다면 데이터 불일치, 누락 문제는 어떻게 해결할 수 있을까요?
DB에서 크롤링된 데이터가 업데이트 되거나, 일부 데이터가 인덱싱 되지 않을 수 있습니다.
이런 데이터는 지속적으로 모니터링하여 변경, 누락 사항을 반영해줘야 합니다.

Codit에서는 airflow를 이용한 자동화 스크립트를 이용하여 데이터를 지속적으로 업데이트하고 인덱싱 해주고 있습니다. 문서의 updatedAt값을 기준으로 변경사항이 있으면 다시 인덱싱하고, 인덱싱이 누락된 데이터가 있는지 모니터링합니다.

# MySQL에서의 검색 vs elasticsearch에서의 검색

정확한 성능 비교는 어렵지만, 한번 단순하게 성능 비교를 해봅시다.

DB에서 약 3000만개의 데이터가 기록된 news 테이블과, ElasticSearch에서 뉴스 데이터를 인덱싱한 인덱스 news-2023,news-2024,news-2025(약 3000만개 데이터) 세 가지를 비교하여 보겠습니다.

---

먼저, DB에 다음과 같은 쿼리를 날립니다.
news 테이블의 press 열에는 인덱스를 걸어두었습니다.

```sql
EXPLAIN ANALYZE
SELECT * FROM news
WHERE press="기독교한국신문"
```

```
-> Index lookup on news_2023 using index_press (press='기독교한국신문')  (cost=3558 rows=3238) (actual time=0.0704..40939 rows=3238 loops=1)↵
```

결과를 해석해보면 첫 데이터를 찾는데에 0.07ms, 마지막 데이터를 찾는데에 40.9초 정도가 소요됐습니다.

---

이번엔 elasticsearch에 아래와 같은 쿼리를 날려봅시다.

```
GET news-2023,news-2024,news-2025/_search
{
  "size": 10000,
  "query": {
    "term": {
      "press": {
        "value": "기독교한국신문"
      }
    }
  }
}
```

![[Pasted image 20250625160011.png]]
우측 상단의 결과를 보면 약 3.2초가 소요됐습니다.

데이터가 다른것과 단순한 시간 비교임을 감안해도 약 10배 이상 검색에 차이가 나는것을 확인할 수 있습니다.

## 왜 이런 성능차이가 날까?

MySQL은 기본적으로 B-Tree 인덱스를 사용합니다.
B-Tree를 탐색해 문서의 주소를 얻은 후, 해당 주소에서 데이터를 읽어옵니다. 읽어오는 행 수가 많으면 I/O비용이 점점 커집니다.

반면, ElasticSearch는 역색인 방식을 사용합니다.
키워드별로 문서의 Id 리스트를 저장해두고, OS의 페이지 캐시(mmap)를 활용해 디스크 I/O를 최소화합니다.

이 외에도 ElasticSearch는 데이터를 여러 샤드에 나누어 저장하고 병렬로 읽어오므로 훨씬 빠른 검색 성능을 보입니다.
