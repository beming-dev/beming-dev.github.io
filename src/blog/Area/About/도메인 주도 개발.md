---
thumbnail: default.jpg
slug: "/blog/about/ddd"
date: "2025-07-28"
title: "도메인 주도 개발(DDD)을 적용해보자"
categories:
  - mainCategory: "Area"
    subCategory: "About"
---

최근 About 프로젝트에 클린 아키텍처를 도입하고 있습니다.

서비스를 Controller, Service, Entity, Repository 정도의 경계로 나누고, 고수준 모듈이 저수준 모듈을 참조하는 (Service에서 Repository를 호출하는) 경우는 interface를 정의하여 의존성을 방향을 제어하도록 구현하고 있습니다.
![[Pasted image 20250627113727.png]]

위 도식에서 추가로 외부에 의존해야 하는게 필요하다면 (ex. 결제 api), interface를 정의해서 interface에만 의존하는 방식으로 구현중에 있습니다.

여기서 DB의존성 제거를 위해 Repository를 분리하기 위해서는, 도메인 엔티티를 정의해야 합니다. 그렇지 않고 DB 스키마를 사용하게 된다면, 완전한 DB의 분리가 이루어졌다고 보기 어렵습니다.

```

```

# 도메인 주도 개발

먼저, 도메인이란 "<b>소프트웨어가 해결하고자 하는 문제 영역</b>" 입니다.
예를 들어, 은행 앱의 도메인을 설계 한다면, 아래와 같은 것들이 도메인이 될 수 있습니다.

- 계좌 정보
- 고객 정보
- 은행 상품
  도메인은 서비스를 운영한다면 필수적으로 존재하게 되는데, 개발자로서 우리는 이를 소프트웨어적으로 구현해야 하므로 <b>도메인 모델</b>을 설계해야 합니다.
  설계 방식에 제약은 없지만 주로 객체를 이용해 설계하는 것이 일반적입니다.

# 설계

먼저 일반적으로 생각했을 때, 해결하려는 하나의 문제가 존재할 것이고, 그 문제를 위해 필요한 엔티티가 여러개 있을 것입니다. 이 하나의 문제를 도메인이라 부릅시다.

도메인을 해결하기 위해서는 여러 엔티티들이 상호작용 해야합니다. 이 수많은 엔티티들 중에는 서로 연관된 것들이 존재합니다. 이런 엔티티를 묶은것을 <b>애그리거트 (Aggregate)</b>라고 부릅시다. 하나의 애그리더트는 <b>애그리거트 루트</b>를 가지고 여러 하위 엔티티를 포함합니다.

예를 들어, 은행 상품 이라는 애그리거트를 설계한다고 생각해봅시다. 하위에

---

### Aggregate 1: Catalog

- Entity1: Product: 상품코드, 이름, 설명
- Entity2: Category: 카테고리 이름, 카테고리 코드
- Entity3: Attribute: 최고한도, 최저예치금

---

### Aggregate2: Definition

- Entity1: RatePlan: 연이율, 적용기간, 변동금리/고정금리
- Entity2: Fee: 수수료 유형, 금액, 비율

---

다음과 같은 Aggregate, Entity가 생성될 것입니다.

# Entity와 Value Object

Entity는 고유한 식별자를 가지고, LifeCycle동안 동일성을 유지해야 합니다.
반면, Value Object는 식별자가 없고, 값 자체로 동일성을 판단합니다.

```JAVA
@Entity
public class User {
    @Id
    private Long id;        // 식별자
    private String name;
    private Email email;    // VO 참조
}

@ValueObject
public class Email {
    private final String address;
    public Email(String address) {
        if (!address.matches(".+@.+\\..+")) {
            throw new IllegalArgumentException("유효하지 않은 이메일");
        }
        this.address = address.toLowerCase();
    }
}
```

엔티티와 Value Object를 구분함으로서, 도메인 모델의 의도를 분명하게 드러낼 수 있습니다.

Entity의 안에는 비즈니스 규칙에 따라 상태가 바뀌는 로직이 들어가고, Value Object는 불변으로 설계하여, 변경이 필요하면 새로운 인스턴스를 생성하여 Side-Effect를 차단할 수 있습니다.

## 불변성

DDD에서 왜 불변성을 챙겨야 할까요?

불변성을 적용하면 다음과 같은 이점을 얻을 수 있습니다.

- 멀티스레드 환경에서 동시성 이슈 감소
- 사이드 이펙트를 방지하여 예측 가능한 동작 보장
- 단위 테스트에서 상태 설정이 간단해짐

아래에서 Money를 불변성을 가진 Value Object로 설계해봅시다.

```Java
public final class Money {
    private final BigDecimal amount;
    private final String currency;

    private Money(BigDecimal amount, String currency) {
        this.amount = amount;
        this.currency = currency;
    }

    public static Money of(BigDecimal amount, String currency) {
        if (amount.signum() < 0) {
            throw new IllegalArgumentException("금액은 음수일 수 없습니다.");
        }
        return new Money(amount, currency);
    }

    // 불변 연산: 새 객체를 반환
    public Money add(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new IllegalArgumentException("통화 단위가 다릅니다.");
        }
        return new Money(this.amount.add(other.amount), currency);
    }

    // Getter만 제공
    public BigDecimal getAmount() { return amount; }
    public String getCurrency() { return currency; }
}
```

위의 코드를 보면, Money 객체에는 내부 필드를 외부에서 조작할 수 있는 set 메서드를 제공하지 않습니다.

유일하게 Money를 변경할 수 있는건 외부에 노출된 add 뿐입니다. 그러나 add 메서드 역시 내부 상태 변경을 허용하지 않고 새로운 Money 객체를 반환합니다.

# Entity, VO, 불변성

Entity와 VO, 불변성은 함께 사용하면 시너지 효과를 얻을 수 있습니다.

1. 도메인의 의도 명확화
   VO를 통해 핵심 값의 비즈니스 규칙을 캡슐화 하고, Entity는 식별과 참조 역할에만 집중합니다.
2. 안정적 모델 유지
   VO에 불변성을 적용하면, Entity 내부의 VO가 의도치 않게 변형되는걸 방지합니다. 따라서 복잡한 트랜잭션, 이벤트에서 안정성이 확보됩니다.
3. 테스트 용이성
   VO 단위 테스트로 값 검사 로직을 검증하면, Entity의 단위 테스트에서 VO의 생성이 보장됩니다.

아래에서 간단한 예시를 확인해봅시다.

먼저, Money 객체에 값 검사 로직을 추가해봅시다.

```java

public final class Money {
    private final BigDecimal amount;
    private final String currency;

    private Money(BigDecimal amount, String currency) {
        this.amount = amount;
        this.currency = currency;
    }

    public static Money of(BigDecimal amount, String currency) {
        if (amount.signum() < 0) {
            throw new IllegalArgumentException("금액은 음수일 수 없습니다.");
        }
        return new Money(amount, currency);
    }

    public Money add(Money other) {
        verifySameCurrency(other);
        return new Money(this.amount.add(other.amount), currency);
    }

    public Money multiply(int quantity) {
        if (quantity < 0) {
            throw new IllegalArgumentException("수량은 음수일 수 없습니다.");
        }
        return new Money(this.amount.multiply(BigDecimal.valueOf(quantity)), currency);
    }

    private void verifySameCurrency(Money other) {
        if (!this.currency.equals(other.currency)) {
            throw new IllegalArgumentException("통화가 다릅니다.");
        }
    }

    public BigDecimal getAmount() { return amount; }
    public String getCurrency() { return currency; }

    @Override public boolean equals(Object o) { /* address equality */ }
    @Override public int hashCode() { /* based on amount & currency */ }
}
```

그리고 이 VO를 Order 객체에서 사용해봅시다.

```java
// Entity: Order
public class Order {
    private final Long id;
    private final String customerId;
    private final List<OrderLine> lines = new ArrayList<>();

    public Order(Long id, String customerId) {
        this.id = id;
        this.customerId = customerId;
    }

    public void addLine(Product product, int quantity) {
        Money lineTotal = product.getPrice().multiply(quantity);
        lines.add(new OrderLine(product.getId(), quantity, lineTotal));
    }

    // 전체 주문 금액 계산
    public Money totalAmount() {
        return lines.stream()
            .map(OrderLine::getLineTotal)
            .reduce(Money.of(BigDecimal.ZERO, lines.get(0).getLineTotal().getCurrency()),
                    Money::add);
    }

    // OrderLine 내부 클래스
    public static class OrderLine {
        private final Long productId;
        private final int quantity;
        private final Money lineTotal;  // VO

        public OrderLine(Long productId, int quantity, Money lineTotal) {
            this.productId = productId;
            this.quantity = quantity;
            this.lineTotal = lineTotal;
        }
        public Money getLineTotal() { return lineTotal; }
    }
}

```

위 예에서 Money는 불변 VO이고, Order Entity는 내부의 OrderLine(주문 상품들) 에서 Money를 가집니다.

- Money(VO) 가 금액 계산, 검증 역할을 전담합니다. 따라서 Order는 주문 로직에만 집중할 수 있습니다.
- Money가 불변 객체이므로, 한번 생성된 금액 정보는 절대 변경되지 않습니다.
- Money의 단위 테스트에서 덧셈, 곱셈, 통화 검증이 완료되면, Order의 단위 테스트에서는 addLine과 totalAmount의 검증만 완료되면 됩니다.

이런 이유로 도메인 주도 개발을 할 때에는 Entity, VO, 불변성 개념을 잘 알고 있는것이 도움이 됩니다.
