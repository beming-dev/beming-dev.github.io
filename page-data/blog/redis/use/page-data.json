{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/redis/use/","result":{"data":{"markdownRemark":{"html":"<h1>Redis design</h1>\n<p>Redis를 사용할 때, 기존의 데이터베이스를 사용할 때와는 다르게 접근해야 합니다.</p>\n<h2>SQL database</h2>\n<ol>\n<li>데이터를 테이블에 집어넣는다.</li>\n<li>어떻게 query해 사용할지 생각한다.</li>\n</ol>\n<h2>Redis</h2>\n<ol>\n<li>답을 얻기 위해 어떤 query가 필요한지 생각한다.</li>\n<li>query에 맞게 데이터를 넣는다.</li>\n</ol>\n<h1>명령어</h1>\n<h2>해시</h2>\n<p>Key-Value 쌍으로 저장할 수 있는 데이터입니다.\n중첩하거나 배열 값을 가질 수는 없습니다.</p>\n<p>다양한 속성이 묶인 item이 있을 때 해시 구조로 저장합니다.</p>\n<h3>HSET</h3>\n<p>HSET [key] [key1] [value] [key2] [value]\nex) HSET company name 'Hello Co' age 1915\ncompany -> name: 'Hello Co', age: 1915</p>\n<ul>\n<li>추가로 알아두어야 할 것은, node-redis와 같은 라이브러리를 사용할 때, null값이 있다면 에러가 발생할 수 있습니다. node-redis 내부적으로 .toString()을 호출하기 때문인데, null || '' 와 같이 사용해주어야 합니다.</li>\n</ul>\n<h3>HGET</h3>\n<p>HGET [key] [key1]\nex) HGET company name // 'Hello Co'</p>\n<p>HGETALL company // {name 'Hello Co', age 1915}</p>\n<ul>\n<li>HGETALL을 할 때, 존재하지 않는 키에 대해 실행하면 {} 빈 Object를 응답으로 받습니다. 이 부분을 유의해서 처리해야 합니다.</li>\n</ul>\n<h3>HEXISTS</h3>\n<p>HEXISTS [key] [key1]\nkey 값 안에 key1의 값이 존재하는지 확인합니다.\nex) HEXISTS company name // 1</p>\n<h3>DEL, HDEL</h3>\n<p>DEL [key]\nkey에 저장된 값을 삭제합니다.\nex) DEL company</p>\n<p>HDEL [key] [key1]\n필드 하나만 삭제합니다.\nex) HDEL company name</p>\n<h3>HINCRBY, HINCRBYFLOAT</h3>\n<p>HINCRBY [key] [key1] [value]\nvalue만큼의 값을 key1 값에 추가합니다.\n해시에 키가 존재하지 않으면 생성합니다.</p>\n<p>HINCRBYFLOAT [key] [key1] [value]\nvalue(실수)만큼의 값을 key1 값에 추가합니다.\n해시에 키가 존재하지 않으면 생성합니다.</p>\n<h3>HSTRLEN</h3>\n<p>HSTRLEN [key] [key1]\nkey1의 길이를 반환합니다. string이 아니면 0을 반환합니다.</p>\n<h3>HKEYS, HVALS</h3>\n<p>HKEYS [key]\nkey에 저장된 값의 key들을 가져옵니다.</p>\n<p>HVALS [key]\nkey에 저장된 값의 value들을 가져옵니다.</p>\n<h2>Set</h2>\n<p>문자열의 집합을 저장합니다. 중복값은 저장되지 않습니다.</p>\n<h3>SADD</h3>\n<p>SADD  [key][value]\nkey 이름으로 set을 생성하고, value를 저장합니다.\n중복 값은 저장되지 않으므로, 저장이 성공하면 1, 실패하면 0을 반환합니다.</p>\n<h3>SMEMBERS</h3>\n<p>SMEMBERS [key]\nkey에 저장된 모든 값을 반환합니다.</p>\n<h3>SUNION</h3>\n<p>SUNION [key1] [key2] [key3] ...</p>\n<p>합집합을 반환하는 명령입니다.</p>\n<p>SUNIONSTORE [key] [key1] [key2] [key3] ...\n명령으로 새로운 key에 바로 저장할 수 있습니다.</p>\n<h3>SDIFF</h3>\n<p>SDIFF [key1] [key2] [key3] ...</p>\n<p>key1의 집합에서 key2이후의 key들의  집합을 뺍니다.\n차집합을 반환하는 명령입니다.</p>\n<p>SDIFFSTORE [key] [key1] [key2] [key3] ...\n명령으로 새로운 key에 바로 저장할 수 있습니다.</p>\n<h3>SINTER</h3>\n<p>SINTER [key1] [key2] [key3] ...</p>\n<p>교집합을 반환하는 명령입니다.</p>\n<p>SINTERSTORE [key] [key1] [key2] [key3] ...\n명령으로 새로운 key에 바로 저장할 수 있습니다.</p>\n<h3>SISMEMBER</h3>\n<p>SISMEMBER [key] [value]</p>\n<p>key에 value가 존재하면 1 존재하지 않으면 0을 반환합니다.</p>\n<h3>SMISMEMBER</h3>\n<p>SMISMEMBER [key] [value1] [value2] [value3] ...</p>\n<p>key에 각 value가 존재하는지를 배열로 반환합니다.</p>\n<h3>SCARD</h3>\n<p>SCARD [key]</p>\n<p>key의 크기(요소의 개수)를 알려줍니다.</p>\n<h3>SREM</h3>\n<p>SCARD [key] [value]</p>\n<p>key 집합에서 value를 제거합니다.</p>\n<h3>SSCAN</h3>\n<p>SSCAN [key] [cursorID] [#of elements]\nex) SSCAN items 0 COUNT 2\n[\n\"3\",\n[\n\"orange\",\n\"red\"\n]\n]</p>\n<p>cursor 값으로 부터 n개 값을 읽어옵니다.\n반환값에 다음 cursor가 포합됩니다.\nSMEMBERS로 데이터를 읽어오기에는 너무 많은 데이터가 있을 때 사용하면 좋습니다.</p>\n<h2>정렬집합</h2>\n<p>정렬집합은 hash와 같이 key value 같이 생긴 값을 내부에 갖습니다.\n하지만 key value 라고 부르지는 않고, member score라 부릅니다.\nmember값은 고유해야 합니다.\nscore는 항상 숫자여야 하고, 내부적으로 score를 기준으로 오름차순으로 정렬됩니다.</p>\n<h3>ZADD</h3>\n<p>ZADD [key] [score] [member]\nkey값의 정렬 집합에 값을 저장합니다.</p>\n<h3>ZSCORE</h3>\n<p>ZSCORE [key] [member]\nkey값의 정렬 집합에서 member의 score를 가져옵니다.</p>\n<h3>ZREM</h3>\n<p>ZREM [key] [member]\nkey값의 정렬 집합에서 member를 삭제합니다.</p>\n<h3>ZCARD</h3>\n<p>ZCARD [key]\nkey의 member 개수를 반환합니다.</p>\n<h3>ZCOUNT</h3>\n<p>ZCOUNT [key] [val1] [val2]\nkey값의 정렬 집합에서 val1과 val2 사이의 값을 가진 member의 개수를 반환합니다. 경계값은 포함합니다.</p>\n<ul>\n<li>val앞에 ( 를 붙히면 경계값을 포함하지 않습니다.</li>\n<li>-inf, +inf 값을 사용할 수 있습니다.</li>\n</ul>\n<h3>ZPOPMIN, ZPOPMAX</h3>\n<p>ZPOPMIN [key] [cnt]\nZPOPMAX [key] [cnt]</p>\n<p>상위, 하위에서 cnt개수 만큼의 값을 가져와 삭제하고 반환합니다.</p>\n<h3>ZINCRBY</h3>\n<p>ZINCRBY [key] [value] [member]\nkey값의 정렬집합에서 member의 값을 value만큼 증가시킵니다.\n음수를 줄 수도 있습니다.</p>\n<h3>ZRANGE</h3>\n<p>ZRANGE [key] [idx1] [idx2] [KEYWORD]\nkey값의 정렬집합에서 idx1~idx2사이의 인덱스를 가진 member를 반환합니다.</p>\n<ul>\n<li>WITHSCORES키워드를 사용하면 score 값도 같이 반환합니다.</li>\n<li>BYSCORE 키워드를 사용하면 idx를 인덱스로 보지 않고 score로 봅니다.</li>\n<li>REV옵션은 정렬집합을 반대로 정렬한 후 결과를 반환합니다.</li>\n<li>LIMIT a b옵션은 a만큼을 건너뛰고 b개만큼을 반환합니다. BYSCORE와 함께 사용해야 합니다.</li>\n</ul>\n<h2>HyperLogLog</h2>\n<p>HyperLogLog는 요소를 실제로 저장하지 않는 데이터 타입입니다.\n내부적으로 복잡한 알고리즘에 의해 문자열을 기억하지만 값이 실제로 저장되지 않습니다.</p>\n<p>관련된 명령어가 두 개밖에 없으므로 간편하게 사용할 수 있습니다.</p>\n<p>어떨때 사용할 수 있을까요?\n만약 상품의 조회수를 증가시킬 때, 사용자 당 한번씩만 증가시키고 싶다고 생각해봅시다.</p>\n<ol>\n<li>SET을 추가하여 itemID마다 view를 증가시킨 userID를 증가시킨다.</li>\n<li>HYPERLOGLOG를 사용한다.</li>\n</ol>\n<p>1번 방법을 사용하는 것도 가능하지만, item마다 조회한 userID를 저장하면, 엄청난 메모리가 필요할 것입니다. 이건 Redis와는 잘 맞지 않습니다.</p>\n<p>HYPERLOG는 안에 값이 얼마나 들어있는지와 상관 없이 12kb만 사용합니다. 하지만 값을 실제로 저장하지 않기 때문에 안에 몇개의 값이 존재하는지 계산하는 명령이 정확하지 않습니다. 대략 0.81%의 에러가 발생한다고 알려져 있습니다.\n하지만 조회수를 계산하는데 저정도의 오차는 그렇게 큰 영향이 아닐겁니다. 그래서 조회수와 같은 로직을 위해 HYPERLOGLOG를 사용한다면, 공간을 많이 아낄 수 있습니다.</p>\n<h3>PFADD</h3>\n<p>PFADD [key]  [value]\n값을 추가합니다.</p>\n<h3>PFCOUNT</h3>\n<p>PFCOUNT [key]\n요소의 추정적인 개수를 반환합니다.</p>\n<h2>LIST</h2>\n<p>Redis에서 List는 이중 연결 리스트 형태로 저장됩니다.</p>\n<p>Redis에서 List는 잘 사용하지 않는게 좋습니다. 비효율적이고, 대부분 다른 데이터 타입으로 더 효율적으로 사용할 수 있습니다.\n데이터의 수정 삭제 없이 끝에 계속 추가하는 경우, 수집된 데이터의 마지막 몇 개만 조회하는 경우 정도가 List와 어울립니다.</p>\n<h3>LPUSH, RPUSH</h3>\n<p>LPUSH [key] [value]\nRPUSH [key] [value]\n각각 List의 왼쪽, 오른쪽에 값을 추가합니다. List의 항목 개수를 반환합니다.</p>\n<h3>LLEN</h3>\n<p>LLEN [key]\nkey에 해당하는 List의 길이를 반환합니다.</p>\n<h3>LINDEX</h3>\n<p>LLEN [key] [idx]\nidx에 해당하는 값을 가져옵니다.\nidx는 음수도 사용할 수 있습니다. -1이 제일 마지막 항목을 의미합니다.</p>\n<h3>LRANGE</h3>\n<p>LRANGE [key] [startIdx] [endIdx]\n특정 범위의 값을 가져옵니다.\nstartIdx와 endIdx에 있는 값을 포함해서 가져옵니다.</p>\n<h3>LPOS</h3>\n<p>LRANGE [key] [value]\nRANK\nCOUNT\nMAXLEN\nkey의 list에서 value 값을 찾습니다. RANK의 값으로 N번째, COUNT값으로 N개, MAXLEN 값으로 최대 N개를 찾도록 할 수 있습니다.</p>\n<h3>LPOP, RPOP</h3>\n<p>LPOP [key]\nRPOP [key]\n각각 왼쪽 끝, 오른쪽 끝에서 값을 하나씩 제거합니다.\n맨 뒤에 숫자 n을 명시하면 n개를 제거합니다.</p>\n<h3>LSET</h3>\n<p>LSET [key] [idx] [value]\nidx위치의 값을 value로 바꿉니다.</p>\n<h3>LTRIM</h3>\n<p>LSET [key] [startIdx] [endIdx]\nstartIdx에서 endIdx 까지를 남겨두고 나머지는 전부 제거합니다.</p>\n<h3>LINSERT</h3>\n<p>LINSERT [key] [BEFORE/AFTER] [value1] [value2]\nvalue1값을 찾은 후, 앞이나 뒤에 value2값을 삽입합니다.</p>\n<h3>LREM</h3>\n<p>LREM [key] [num] [value]\nvalue의 값을 num개 제거하는 명령입니다.\nnum이 양수라면 왼쪽에서 오른쪽으로 찾으며 제거하고,\nnum이 음수라면 오른쪽에서 왼쪽으로 찾으며 제거합니다.\nnum에 0을 입력하면 value 전부를 지웁니다.</p>","frontmatter":{"date":"February 18, 2025","title":"Redis 사용하기"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#redis-design\">Redis design</a></p>\n<ul>\n<li><a href=\"#sql-database\">SQL database</a></li>\n<li><a href=\"#redis\">Redis</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%AA%85%EB%A0%B9%EC%96%B4\">명령어</a></p>\n<ul>\n<li>\n<p><a href=\"#%ED%95%B4%EC%8B%9C\">해시</a></p>\n<ul>\n<li><a href=\"#hset\">HSET</a></li>\n<li><a href=\"#hget\">HGET</a></li>\n<li><a href=\"#hexists\">HEXISTS</a></li>\n<li><a href=\"#del-hdel\">DEL, HDEL</a></li>\n<li><a href=\"#hincrby-hincrbyfloat\">HINCRBY, HINCRBYFLOAT</a></li>\n<li><a href=\"#hstrlen\">HSTRLEN</a></li>\n<li><a href=\"#hkeys-hvals\">HKEYS, HVALS</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#set\">Set</a></p>\n<ul>\n<li><a href=\"#sadd\">SADD</a></li>\n<li><a href=\"#smembers\">SMEMBERS</a></li>\n<li><a href=\"#sunion\">SUNION</a></li>\n<li><a href=\"#sdiff\">SDIFF</a></li>\n<li><a href=\"#sinter\">SINTER</a></li>\n<li><a href=\"#sismember\">SISMEMBER</a></li>\n<li><a href=\"#smismember\">SMISMEMBER</a></li>\n<li><a href=\"#scard\">SCARD</a></li>\n<li><a href=\"#srem\">SREM</a></li>\n<li><a href=\"#sscan\">SSCAN</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%A0%95%EB%A0%AC%EC%A7%91%ED%95%A9\">정렬집합</a></p>\n<ul>\n<li><a href=\"#zadd\">ZADD</a></li>\n<li><a href=\"#zscore\">ZSCORE</a></li>\n<li><a href=\"#zrem\">ZREM</a></li>\n<li><a href=\"#zcard\">ZCARD</a></li>\n<li><a href=\"#zcount\">ZCOUNT</a></li>\n<li><a href=\"#zpopmin-zpopmax\">ZPOPMIN, ZPOPMAX</a></li>\n<li><a href=\"#zincrby\">ZINCRBY</a></li>\n<li><a href=\"#zrange\">ZRANGE</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#hyperloglog\">HyperLogLog</a></p>\n<ul>\n<li><a href=\"#pfadd\">PFADD</a></li>\n<li><a href=\"#pfcount\">PFCOUNT</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#list\">LIST</a></p>\n<ul>\n<li><a href=\"#lpush-rpush\">LPUSH, RPUSH</a></li>\n<li><a href=\"#llen\">LLEN</a></li>\n<li><a href=\"#lindex\">LINDEX</a></li>\n<li><a href=\"#lrange\">LRANGE</a></li>\n<li><a href=\"#lpos\">LPOS</a></li>\n<li><a href=\"#lpop-rpop\">LPOP, RPOP</a></li>\n<li><a href=\"#lset\">LSET</a></li>\n<li><a href=\"#ltrim\">LTRIM</a></li>\n<li><a href=\"#linsert\">LINSERT</a></li>\n<li><a href=\"#lrem\">LREM</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"id":"c3987898-b3e7-5e1e-8378-eccfc8a50b89","frontmatter__slug":"/blog/redis/use","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["2018336255","2540505676","2678393935","2810064759","3398502926"],"slicesMap":{}}