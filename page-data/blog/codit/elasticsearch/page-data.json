{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/codit/elasticsearch/","result":{"data":{"markdownRemark":{"html":"<p>코딧은 크롤링을 통해 다양한 뉴스, 법안, 회의록 데이터를 수집하고 있습니다.</p>\n<p>또한 DB에 저장된 수천만 ~ 수억개의 데이터를 사용자들에게 효율적이고 빠르게, 그리고 다양한 방식으로 검색을 제공해야 합니다.</p>\n<p>데이터베이스를 MySQL을 사용한다고 가정하면, MySQL만으로 충분한 성능의 기능을 제공할 수 있을까요?</p>\n<h1>MySQL에서의 서비스 제공</h1>\n<p>MySQL에서 다양한 조건으로 빠른 검색을 제공하기 위해서는 아래와 같은 방법들을 생각해볼 수 있습니다</p>\n<h2>인덱스 설계</h2>\n<ul>\n<li>자주 조회되는 키를 기준으로 인덱스를 설계합니다.</li>\n<li>Full Text 인덱스를 추가하여 전문에서 검색이 용이하도록 합니다.</li>\n<li>두개 이상의 인덱스를 묶어 복잡한 조건에서도 인덱스를 탈 수 있도록 합니다.</li>\n</ul>\n<p>MySQL에서 인덱스를 해두는것과 해두지 않는것은 데이터의 크기가 클 수록 조회속도에서의 차이가 큽니다.</p>\n<p>인덱스를 잘 설계하면 빠른 검색을 기대할 수 있지만, 검색 조건이 다양해질수록 제대로된 인덱스를 설계하기가 어려워집니다.</p>\n<p>또한 인덱스는 읽기 속도를 높혀주지만, 나머지 연산(INSERT, UPDATE, DELETE)의 연산속도는 늦춥니다. 따라서 지속적으로 데이터를 쓰고 수정해야하는 크롤링 데이터에 너무 많은 인덱스를 걸어놓는건 성능에 좋지 않을겁니다.</p>\n<h2>데이터 분할, 샤딩</h2>\n<ul>\n<li>데이터를 년도별, 혹은 다른 기준으로 파티셔닝 해둘 수 있습니다.</li>\n<li>애플리케이션에서 특정 shardId를 계산해 어떤 DB 인스턴스에 접근할지 결정할 수 있습니다.</li>\n<li>프록시, 미들웨어에서 샤딩을 관리할 수 있습니다.</li>\n<li>MySQL 전용 샤딩 솔루션(Vitess 등)을 사용합니다.</li>\n</ul>\n<p>위와같이 데이터를 분할, 샤딩하여 관리할 수도 있습니다.\n하지만 여러 MySQL 인스턴스가 필요할 수 있고, 저희 서비스의 성격과 잘 맞지 않는 방식입니다.</p>\n<h1>Elasticsearch 도입</h1>\n<p>MySQL만으로 풀텍스트 검색과 대용량 분산 처리를 모두 커버하기엔 한계가 있습니다. 특히 <strong>다양한 언어 분석</strong>, <strong>실시간 색인</strong>, <strong>수평 확장</strong>이 필요한 경우에는 Elasticsearch 도입을 고려해볼 수 있습니다.</p>\n<h2>어떤점이 좋을까?</h2>\n<p>먼저, ElasticSearch는 오픈소스입니다. 충분한 자원과 약간의 learning curve만 넘으면 누구나 사용할 수 있습니다.</p>\n<p>문서 단위로 인덱스를 생성하고, 역색인 방식으로 빠른 검색을 제공합니다.\nMySQL의 Full-Text는 문서 단위 검색에 제한이 있지만, ES는 토큰화, 형태소 분석 등 다양한 분석기를 제공합니다.</p>\n<p>또한 자동으로 데이터를 샤딩하여 저장하고, 내부적으로 노드를 재배치 하는 작업도 진행합니다.\nMaster-Data 노드를 구분해 고가용성 및 장애 복구를 지원합니다.</p>\n<h2>고려해야 할 점은?</h2>\n<p>elasticsearch의 도입은 확실히 관리 리소스를 증가시킵니다.\nDB에 있는 데이터를 elasticsearch에 인덱싱 해야하므로 데이터의 불일치, 누락이 발생할 수 있고 elasticsearch용 쿼리를 설계해야 하는 불편함이 있습니다.</p>\n<p>Codit 서비스는 주로 크롤링한 데이터, api에서 받아온 데이터를 서빙합니다.\n그러기 위해선 받아온 데이터를 DB에 저장하고, 서비스에서 사용하기 좋은 형태로 가공하는 과정이 필요합니다.</p>\n<p>특히 크롤링 된 데이터는 완벽할 수 없습니다. 크롤링 된 데이터를 바로 사용한다면, 비즈니스 로직쪽에 DB에서 데이터를 가져와 전, 후처리 해주는 로직이 들어가게 됩니다.</p>\n<p>그러나 이 부분을 elasticsearch에 indexing하는 과정에서 처리한다면 코드를 조금 더 깔끔하게 분리할 수 있습니다.</p>\n<p>그렇다면 데이터 불일치, 누락 문제는 어떻게 해결할 수 있을까요?\nDB에서 크롤링된 데이터가 업데이트 되거나, 일부 데이터가 인덱싱 되지 않을 수 있습니다.\n이런 데이터는 지속적으로 모니터링하여 변경, 누락 사항을 반영해줘야 합니다.</p>\n<p>Codit에서는 airflow를 이용한 자동화 스크립트를 이용하여 데이터를 지속적으로 업데이트하고 인덱싱 해주고 있습니다. 문서의 updatedAt값을 기준으로 변경사항이 있으면 다시 인덱싱하고, 인덱싱이 누락된 데이터가 있는지 모니터링합니다.</p>\n<h1>MySQL에서의 검색 vs elasticsearch에서의 검색</h1>\n<p>정확한 성능 비교는 어렵지만, 한번 단순하게 성능 비교를 해봅시다.</p>\n<p>DB에서 약 3000만개의 데이터가 기록된 news 테이블과, ElasticSearch에서 뉴스 데이터를 인덱싱한 인덱스 news-2023,news-2024,news-2025(약 3000만개 데이터) 세 가지를 비교하여 보겠습니다.</p>\n<hr>\n<p>먼저, DB에 다음과 같은 쿼리를 날립니다.\nnews 테이블의 press 열에는 인덱스를 걸어두었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"sql\"><pre class=\"language-sql\"><code class=\"language-sql\"><span class=\"token keyword\">EXPLAIN</span> <span class=\"token keyword\">ANALYZE</span>\n<span class=\"token keyword\">SELECT</span> <span class=\"token operator\">*</span> <span class=\"token keyword\">FROM</span> news\n<span class=\"token keyword\">WHERE</span> press<span class=\"token operator\">=</span><span class=\"token string\">\"기독교한국신문\"</span></code></pre></div>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">-> Index lookup on news_2023 using index_press (press='기독교한국신문')  (cost=3558 rows=3238) (actual time=0.0704..40939 rows=3238 loops=1)↵</code></pre></div>\n<p>결과를 해석해보면 첫 데이터를 찾는데에 0.07ms, 마지막 데이터를 찾는데에 40.9초 정도가 소요됐습니다.</p>\n<hr>\n<p>이번엔 elasticsearch에 아래와 같은 쿼리를 날려봅시다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">GET news-2023,news-2024,news-2025/_search\n{\n  \"size\": 10000,\n  \"query\": {\n    \"term\": {\n      \"press\": {\n        \"value\": \"기독교한국신문\"\n      }\n    }\n  }\n}</code></pre></div>\n<p>![[Pasted image 20250625160011.png]]\n우측 상단의 결과를 보면 약 3.2초가 소요됐습니다.</p>\n<p>데이터가 다른것과 단순한 시간 비교임을 감안해도 약 10배 이상 검색에 차이가 나는것을 확인할 수 있습니다.</p>\n<h2>왜 이런 성능차이가 날까?</h2>\n<p>MySQL은 기본적으로 B-Tree 인덱스를 사용합니다.\nB-Tree를 탐색해 문서의 주소를 얻은 후, 해당 주소에서 데이터를 읽어옵니다. 읽어오는 행 수가 많으면 I/O비용이 점점 커집니다.</p>\n<p>반면, ElasticSearch는 역색인 방식을 사용합니다.\n키워드별로 문서의 Id 리스트를 저장해두고, OS의 페이지 캐시(mmap)를 활용해 디스크 I/O를 최소화합니다.</p>\n<p>이 외에도 ElasticSearch는 데이터를 여러 샤드에 나누어 저장하고 병렬로 읽어오므로 훨씬 빠른 검색 성능을 보입니다.</p>","frontmatter":{"date":"July 14, 2025","title":"왜 ElasticSearch를 사용할까?"},"tableOfContents":"<ul>\n<li>\n<p><a href=\"#mysql%EC%97%90%EC%84%9C%EC%9D%98-%EC%84%9C%EB%B9%84%EC%8A%A4-%EC%A0%9C%EA%B3%B5\">MySQL에서의 서비스 제공</a></p>\n<ul>\n<li><a href=\"#%EC%9D%B8%EB%8D%B1%EC%8A%A4-%EC%84%A4%EA%B3%84\">인덱스 설계</a></li>\n<li><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0-%EB%B6%84%ED%95%A0-%EC%83%A4%EB%94%A9\">데이터 분할, 샤딩</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#elasticsearch-%EB%8F%84%EC%9E%85\">Elasticsearch 도입</a></p>\n<ul>\n<li><a href=\"#%EC%96%B4%EB%96%A4%EC%A0%90%EC%9D%B4-%EC%A2%8B%EC%9D%84%EA%B9%8C\">어떤점이 좋을까?</a></li>\n<li><a href=\"#%EA%B3%A0%EB%A0%A4%ED%95%B4%EC%95%BC-%ED%95%A0-%EC%A0%90%EC%9D%80\">고려해야 할 점은?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#mysql%EC%97%90%EC%84%9C%EC%9D%98-%EA%B2%80%EC%83%89-vs-elasticsearch%EC%97%90%EC%84%9C%EC%9D%98-%EA%B2%80%EC%83%89\">MySQL에서의 검색 vs elasticsearch에서의 검색</a></p>\n<ul>\n<li><a href=\"#%EC%99%9C-%EC%9D%B4%EB%9F%B0-%EC%84%B1%EB%8A%A5%EC%B0%A8%EC%9D%B4%EA%B0%80-%EB%82%A0%EA%B9%8C\">왜 이런 성능차이가 날까?</a></li>\n</ul>\n</li>\n</ul>"}},"pageContext":{"id":"027fbdeb-b3a3-5bc5-9472-9580e9e24713","frontmatter__slug":"/blog/codit/elasticsearch","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["2018336255","2540505676","2678393935","2810064759","3398502926"],"slicesMap":{}}