{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/about/caching/","result":{"data":{"markdownRemark":{"html":"<h1>시간이 오래걸리는 API를 찾아내보자</h1>\n<p>현재 About 서비스는 Docker에서 생성되는 모든 로그를 ELK 스택으로 수집하고 분석하고 있습니다.\n원래는 단순하게 에러 로그만 수집하여 사용했는데, 이를 잘 활용하면 각 API의 처리 속도도 분석해볼 수 있겠다 생각했습니다.</p>\n<p>이를 위해서는 먼저 Nest.js로 들어오는 모든 요청의 URL과 실행 시간을 로깅해야 합니다.\n그래서 다음과 같은 middleware를 두었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">Injectable</span></span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">LoggingMiddleware</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">NestMiddleware</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>\n    <span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">Inject</span></span><span class=\"token punctuation\">(</span><span class=\"token constant\">WINSTON_MODULE_PROVIDER</span><span class=\"token punctuation\">)</span> <span class=\"token keyword\">private</span> <span class=\"token keyword\">readonly</span> logger<span class=\"token operator\">:</span> LoggerService<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  \n  <span class=\"token function\">use</span><span class=\"token punctuation\">(</span>req<span class=\"token operator\">:</span> Request<span class=\"token punctuation\">,</span> res<span class=\"token operator\">:</span> Response<span class=\"token punctuation\">,</span> next<span class=\"token operator\">:</span> NextFunction<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> startTime <span class=\"token operator\">=</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n    <span class=\"token comment\">// 요청 로깅 (JSON 형식)</span>\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n      timestamp<span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toISOString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      level<span class=\"token operator\">:</span> <span class=\"token string\">'info'</span><span class=\"token punctuation\">,</span>\n      message<span class=\"token operator\">:</span> <span class=\"token string\">'Incoming Request'</span><span class=\"token punctuation\">,</span>\n      method<span class=\"token operator\">:</span> req<span class=\"token punctuation\">.</span>method<span class=\"token punctuation\">,</span>\n      url<span class=\"token operator\">:</span> req<span class=\"token punctuation\">.</span>originalUrl<span class=\"token punctuation\">,</span>\n      ip<span class=\"token operator\">:</span> req<span class=\"token punctuation\">.</span>ip<span class=\"token punctuation\">,</span>\n      userAgent<span class=\"token operator\">:</span> req<span class=\"token punctuation\">.</span>headers<span class=\"token punctuation\">[</span><span class=\"token string\">'user-agent'</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n      body<span class=\"token operator\">:</span> req<span class=\"token punctuation\">.</span>body<span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n    res<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'finish'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> duration <span class=\"token operator\">=</span> Date<span class=\"token punctuation\">.</span><span class=\"token function\">now</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">-</span> startTime<span class=\"token punctuation\">;</span>\n  \n      <span class=\"token comment\">// 응답 로깅 (JSON 형식)</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>logger<span class=\"token punctuation\">.</span><span class=\"token function\">log</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span>\n        timestamp<span class=\"token operator\">:</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Date</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toISOString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n        level<span class=\"token operator\">:</span> <span class=\"token string\">'info'</span><span class=\"token punctuation\">,</span>\n        message<span class=\"token operator\">:</span> <span class=\"token string\">'Outgoing Response'</span><span class=\"token punctuation\">,</span>\n        method<span class=\"token operator\">:</span> req<span class=\"token punctuation\">.</span>method<span class=\"token punctuation\">,</span>\n        url<span class=\"token operator\">:</span> req<span class=\"token punctuation\">.</span>originalUrl<span class=\"token punctuation\">,</span>\n        statusCode<span class=\"token operator\">:</span> res<span class=\"token punctuation\">.</span>statusCode<span class=\"token punctuation\">,</span>\n        duration<span class=\"token operator\">:</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>duration<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n    <span class=\"token function\">next</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<ul>\n<li>요청이 들어올 때, ip timestamp url등의 정보를 기록합니다.</li>\n<li>요청이 종료될 때, url과 duration등의 정보를 기록합니다.</li>\n</ul>\n<p>이 middleware를 Global로 적용한다면, 들어오고 나가는 모든 요청을 로깅하게 됩니다.</p>\n<h1>이 로그를 Kibana에서 어떻게 시각화할 수 있을까요?</h1>\n<p>ELK 스택은 잘 구성돼있다 가정하겠습니다.</p>\n<p>먼저, ElasticSearch는 인덱스 생성 시 특별한 설정이 없다면 데이터를 text타입으로 저장합니다. 이 text 타입은 문자가 분해되어 저장되기 때문에, 시각화에 사용하기 어렵습니다. 그래서 시각화할 필드의 타입을 다르게 바꿔줘야 합니다.</p>\n<p>타입은 수정이 불가능하기 때문에, reindexing 하는 과정이 필요합니다.\n아래 명령은 새로운 template를 적용하는 명령입니다. 이 template이 적용된 후 생성되는 index에는 변경된 타입이 반영됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">PUT _template/nest-logs-template\n{\n  \"index_patterns\": [\"nest-logs-*\"], \n  \"mappings\": {\n    \"properties\": {\n      \"parsed_json.duration\": {\n        \"type\": \"integer\"\n      }\n    }\n  }\n}\n\nPUT _template/nest-logs-template\n{\n  \"index_patterns\": [\"nest-logs-*\"], \n  \"mappings\": {\n    \"properties\": {\n      \"parsed_json.url\": {\n        \"type\": \"keyword\"\n      }\n    }\n  }\n}</code></pre></div>\n<ul>\n<li>먼저,  Duration 필드를 integer type으로 지정합니다. 숫자 타입으로 인식되기 때문에, 최대값, 평균값등 분석에 사용할 수 있습니다.</li>\n<li>url 필드를 keyword type으로 지정합니다. 문자열은 기본적으로 text 타입으로 저장되어 tokenize되지만, keyword type을 지정하면 문자 자체를 저장합니다. 따라서 url을 분석 대상으로 사용할 수 있습니다.</li>\n</ul>\n<p>다음으로, 기존 index들을 reindexing 해줘야 합니다. template이 적용돼있으므로 바뀐 type이 적용된 index가 생성됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">POST _reindex\n{\n  \"source\": {\n    \"index\": \"nest-logs-2025.03.09\"\n  },\n  \"dest\": {\n    \"index\": \"nest-logs-2025.03.09-reindexed\"\n  }\n}</code></pre></div>\n<p>이 과정이 모두 성공했으면 이제 url과 duration을 시각화에 사용할 수 있습니다.</p>\n<p>이제 아래의 과정을 거치면 각 url 별로, 평균 처리 시간을 확인할 수 있습니다.</p>\n<ol>\n<li>햄버거 메뉴에서 visualization library를 선택하여 create 버튼을 누른 후, Lens를 선택합니다.</li>\n<li>parsed_json.url(이름 다를 수 있음) 필드를 드래그 하여 놓으면, Horizontal axis가 \"Top values of parsed_json.url\"로 설정됩니다.</li>\n<li>오른쪽의 Vertical axios 를 선택한 후, Average와 parsed_json.duration을 선택합니다.</li>\n</ol>\n<p>그럼 아래와 같은 그래프가 완성됩니다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 54%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAABYlAAAWJQFJUiTwAAAB/0lEQVR42p1SS2vVQBjNv1TQiii4KAouXBaEIq6LuFCwFBTswi4q4gUflZaqVPG+tLSXUrC3tbmvPCfJTGYyk+M3ydVWfCwcOJnXN+c7J9/nHEQRel6MQz+HOw6Qpim0MSi0/i84k0ggTARtLEkJVZgKdm0hla72UpnprP8JJ2YZYiK0wbkswHOFKM0QRgkY3Rk651xBSg0hFESuK/K/wUnocS5VpVCqAqmQ9EiioDUTGfqRT0lkbanQ0BRnTPlH2DsnICVeEIOTOqsgizPosoQdndEhzjUW4bK4ym6qcwsznek7jf2xdvyQ4eh4gCBOkDGO1GN1OClsDvo4//wBxiwh65gS4heC3wgznsPzA4wmHhSRKJJtq6zJZmvYx6XGEr6MjrHvjdHb7aHb/Yx2u41Wq4WMftdplRUhSzK4gyGCIETGBXIqilVSUKKm+xWza8tY3H6HhQ8vMHdrHleuzuLshRmcuTiDZx/fVkTGmBPCJOXwSWFEljkR2tLracCnwQEuv3yI+50NLDTXcO3VY8xvPsX118u4ubmKG+tPaqLTllnCEYQxUi6hbNsw8ZNw13Nxe6uB1b0OVvZauNN+g0c7W7jbWcfS9nvc626gMz7CtySolVrC0SSAO/QgqN8YFSTcH9YZy9pKSe1gYYcUOVIqkCBXtj9tjDTkqDyx/B05Vj0YtgqCjgAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"20250317172315\"\n        title=\"\"\n        src=\"/static/8c84ef6528d211c07e190034f54bef68/5a190/20250317172315.png\"\n        srcset=\"/static/8c84ef6528d211c07e190034f54bef68/772e8/20250317172315.png 200w,\n/static/8c84ef6528d211c07e190034f54bef68/e17e5/20250317172315.png 400w,\n/static/8c84ef6528d211c07e190034f54bef68/5a190/20250317172315.png 800w,\n/static/8c84ef6528d211c07e190034f54bef68/c1b63/20250317172315.png 1200w,\n/static/8c84ef6528d211c07e190034f54bef68/29007/20250317172315.png 1600w,\n/static/8c84ef6528d211c07e190034f54bef68/9efb3/20250317172315.png 1894w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>먼저 시간이 가장 오래걸린 /admin/user/~는 모든 유저 정보를 가져오는 관리자가 사용하는 api입니다. 속도가 느려도 유저들이 체감할 수 없습니다.</p>\n<p>그 다음으로 속도가 느린 api는 /groupstudy/snapshot 요청입니다. Groupstudy의 데이터를 populate해서 전부 가져오는 요청인데, 자주 호출되고 매우 큰 양의 데이터를 가져옵니다. 이 api의 속도를 한번 개선해봅시다.</p>\n<h1>Redis 캐싱을 적용해보자.</h1>\n<p>/groupstudy/snapshot은 groupstudy의 모든 데이터를 가져온 후, 메인페이지에서 사용하기 좋게 가공하는 과정을 포함합니다. groupstudy의 모든 데이터가 양이 크고 가공하는 로직이 포함돼있어서 시간이 오래걸린다고 생각해볼 수 있습니다.</p>\n<p>그렇다면 가공된 데이터 전체를 Redis에 캐싱하면 어떨까요?</p>\n<p>아래 이미지는 /groupstudy/snapshot api를 로컬에서 여러번 실행했을 때 걸리는 시간입니다. 보통 800ms 전후로 실행되는걸 확인할 수 있었습니다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 132%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAaCAYAAAC3g3x9AAAACXBIWXMAAA7DAAAOwwHHb6hkAAAEHElEQVR42mVV6ZKzNhDkHbZqvcbG5hCHAQFCHDbGleT9H2rSLbC/TeXHFELSNN1z4embkhqmi0TSJBQVhtLebpIWhaRZJtcgED/OpLi/xBgjrelFYf/w8yOH74PEcSwZ3uMoEqWUeFmaSttb6Rsttiyk0bV0sCxVksa4lMRyxUdoeYa7TYPzyhmBU/gT8Bycpaoq8aIoFlXUkueZVHkqZaakgtVY13j2XescgstFcjAwYG+0FlMDtK6lx3qExdcrMHLxSDlWoVyuFzmfA9hZTjA+/dNJyrL8AKZJIg1CoeCcgnEGS66hFDhXOOM9LwJg2xoZplmatgOjTixiNdheuraVvu9dbAhIJ7IbsUfj2uL+fVmk1vWbYSKq7KWyq1T9Ik/bwVr5e+pFlzdc1C5OAZKj8LTDIPP9Lg+A8NlbK/M8Swfgj2SVJwh6hMBenCPlBk6y7y45hthPwNAO1mV7APA4jmIBSGNCnOQkUcickXG6O+m23+SOuGTwVV5MfgEaSO0AqNtGWpxzTXYFYkvzlEolcZJfsKeTvOySm6qUEMyvSMIFMWSJNcgss12C+Q3GNVUwLE4yv67yGI4hJAdyQmadZNQV12RGQFoOpxF1WIOphl+FZwmrwIzVsAFSsqbkGRI2ydZ02EONYc24kB0BmeUHQtGhFglUArTAU+1dsklOMye5pORhlXUwTvZfI9qshuRok8xOKeA0wcmCicGHWqzZORnemUTHMMdmskumvHdRf7L9SzIL2yBJLcygpNq9UzTsBtaO4R/Je5Yhd+i3LPfmj2QyTckQjGgWYA8U/sBGQClF7HUypGRVDZD7gmxkeehkheR/kOW22iQTkPXKjN7htIANbUAiHijuW1m5BDpApjuKwABM6RyH1z0JFzyDT0IinBFwAsjMAQHnARNqnSaXpAihcYDbLEPjl9rJu6XJJ2bv+vvEEIANnDOCs8NgF7Ykngbyd8ko7CxydccEBL8AfgOSfQZAC4a0DsZOqTDGNGcpYu4AL3s2ORfDKHTr4/H4P/vBhOYZQ8QWZMx838cHEQ500/Ho72XD9mEdgQk3ff8PCB3842bvD3H0v8+OWJ+CqyzLC00wwgbxpnlyzd0iBoZdYrdp0rD5sad14+qs0ds7x9dmVmqUToL4kfH7V+A9Hg9pUFecbwQqEPQE/xHGk/F7F/b5fPoU+6fw+QMD0+/vb/n6+nLN4T3doJxlwGzjoLQoas66eX7I87m69bquMuGM58tzgcRFJpQLp3mEH9nhcHCgLC2PzCiFF8Zxu8R3thKNMlKMuKLY3jXUUBHDxB4meybsA/haXw5kWZ6OTbWPIf6TCcDYlOhdvnM/y3LXsyw3ThiG5T+A2+gmQLoBZKlz4Hwr8U4Qrt8DlPd5b9tTW7aRdQKyPf8FL433aB9NzboAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"20250315155814\"\n        title=\"\"\n        src=\"/static/1898d6c830ee483661ac32ba0a4a4bc7/5a190/20250315155814.png\"\n        srcset=\"/static/1898d6c830ee483661ac32ba0a4a4bc7/772e8/20250315155814.png 200w,\n/static/1898d6c830ee483661ac32ba0a4a4bc7/e17e5/20250315155814.png 400w,\n/static/1898d6c830ee483661ac32ba0a4a4bc7/5a190/20250315155814.png 800w,\n/static/1898d6c830ee483661ac32ba0a4a4bc7/ae77d/20250315155814.png 1111w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>한번 코드에 Redis 캐싱을 적용해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">async</span> <span class=\"token function\">getGroupStudySnapshot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">let</span> groupStudyData<span class=\"token punctuation\">;</span>\n\tgroupStudyData <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>redisClient<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token constant\">GROUPSTUDY_FULL_DATA_KEY</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>groupStudyData<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">await</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>groupStudyData<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n\t<span class=\"token comment\">//그 외 로직</span>\n\t\n\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>redisClient<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>\n      <span class=\"token constant\">GROUPSTUDY_FULL_DATA_KEY</span><span class=\"token punctuation\">,</span>\n      <span class=\"token comment\">//returnVal은 최종 가공된 데이터가 들어갑니다.</span>\n      <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>returnVal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'EX'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token number\">60</span> <span class=\"token operator\">*</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    \n\t<span class=\"token keyword\">return</span> returnVal<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>Redis가 적용되는 로직만 작성했습니다.\nGROUPSTUDY_FULL_DATA_KEY값의 데이터가 있는지 확인하고, 있다면 그 값을 return 합니다.\n그리고 데이터가 없다면, 모든 과정을 마친 후 최종 데이터를 GROUPSTUDY_FULL_DATA_KEY를 key로하여 저장합니다.</p>\n<h1>이제 API 요청이 빨라졌을까?</h1>\n<p>결론부터 말하면, 이 방식을 적용한 후 오히려 API 응답 속도가 1000ms대로 느려졌습니다(로컬 기준).</p>\n<p>그 원인에 대해 생각해본 결과, 최종 결과 데이터가 너무 크기 때문에 네트워크 전송 속도, Redis에서 읽고 쓰는 속도 등이 영향을 준 것이 아닐까 생각했습니다.</p>\n<p>그렇다면 이를 어떻게 해결할 수 있을까요?\n압축을 사용하면 됩니다.</p>\n<h1>데이터를 압축하여 다시 캐싱해보자</h1>\n<p>아래는 수정된 코드입니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">const</span> gzip <span class=\"token operator\">=</span> <span class=\"token function\">promisify</span><span class=\"token punctuation\">(</span>zlib<span class=\"token punctuation\">.</span>gzip<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> gunzip <span class=\"token operator\">=</span> <span class=\"token function\">promisify</span><span class=\"token punctuation\">(</span>zlib<span class=\"token punctuation\">.</span>gunzip<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">async</span> <span class=\"token function\">getGroupStudySnapshot</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n\t<span class=\"token keyword\">let</span> groupStudyData<span class=\"token punctuation\">;</span>\n    groupStudyData <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>redisClient<span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span><span class=\"token constant\">GROUPSTUDY_FULL_DATA</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>groupStudyData<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">return</span> <span class=\"token keyword\">await</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>\n        <span class=\"token punctuation\">(</span><span class=\"token keyword\">await</span> <span class=\"token function\">gunzip</span><span class=\"token punctuation\">(</span>Buffer<span class=\"token punctuation\">.</span><span class=\"token function\">from</span><span class=\"token punctuation\">(</span>groupStudyData<span class=\"token punctuation\">,</span> <span class=\"token string\">'base64'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    \n   <span class=\"token comment\">//그 외 로직</span>\n\t<span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>redisClient<span class=\"token punctuation\">.</span><span class=\"token function\">set</span><span class=\"token punctuation\">(</span>\n      <span class=\"token constant\">GROUPSTUDY_FULL_DATA</span><span class=\"token punctuation\">,</span>\n      <span class=\"token punctuation\">(</span><span class=\"token keyword\">await</span> <span class=\"token function\">gzip</span><span class=\"token punctuation\">(</span><span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">stringify</span><span class=\"token punctuation\">(</span>returnVal<span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token string\">'base64'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">,</span>\n      <span class=\"token string\">'EX'</span><span class=\"token punctuation\">,</span>\n      <span class=\"token number\">60</span> <span class=\"token operator\">*</span> <span class=\"token number\">30</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n\t<span class=\"token keyword\">return</span> retuenVal<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>압축을 위해 zlib 라이브러리를 사용했습니다.</p>\n<p>압축한 데이터를 캐싱하는 코드를 적용했습니다. 추가적인 처리를 하고 실행시간을 확인해봅시다.</p>\n<h1>캐싱된 데이터에 추가적인 처리가 필요합니다.</h1>\n<p>캐싱기능이 완료됐을까요? 아직 아닙니다.\n캐싱은 말 그대로 데이터를 그대로 캐시에 저장하고 있는 것입니다.\n데이터에 변경이 일어나도 캐싱된 데이터는 변경되지 않기때문에, 이 부분의 처리가 필요합니다.\n지금은 누군가 groupstudy를 만들거나 참여해도, 유저한테 보이지 않을 것입니다.</p>\n<p>저는 이 문제를 /groupstudy로 GET이 아닌 요청이 들어올 경우, 캐싱된 데이터를 삭제하여 해결했습니다.</p>\n<p>Nest.js에서는 middleware로 이 문제를 해결해도 되고, Interceptor로 해결할 수도 있습니다. 저는 Interceptor 방식을 선택했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"typescript\"><pre class=\"language-typescript\"><code class=\"language-typescript\"><span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GroupStudyInterceptor</span> <span class=\"token keyword\">implements</span> <span class=\"token class-name\">NestInterceptor</span> <span class=\"token punctuation\">{</span>\n\n  <span class=\"token function\">constructor</span><span class=\"token punctuation\">(</span>\n    <span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">Inject</span></span><span class=\"token punctuation\">(</span><span class=\"token constant\">REDIS_CLIENT</span><span class=\"token punctuation\">)</span>\n    <span class=\"token keyword\">private</span> <span class=\"token keyword\">readonly</span> redisClient<span class=\"token operator\">:</span> Redis<span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span><span class=\"token punctuation\">}</span>\n  <span class=\"token function\">intercept</span><span class=\"token punctuation\">(</span>\n    context<span class=\"token operator\">:</span> ExecutionContext<span class=\"token punctuation\">,</span>\n    next<span class=\"token operator\">:</span> CallHandler<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">></span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> Observable<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">></span> <span class=\"token operator\">|</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span>Observable<span class=\"token operator\">&lt;</span><span class=\"token builtin\">any</span><span class=\"token operator\">>></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">const</span> request <span class=\"token operator\">=</span> context<span class=\"token punctuation\">.</span><span class=\"token function\">switchToHttp</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">getRequest</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  \n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>request<span class=\"token punctuation\">.</span>url<span class=\"token punctuation\">.</span><span class=\"token function\">startsWith</span><span class=\"token punctuation\">(</span><span class=\"token string\">'/groupStudy'</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">&amp;&amp;</span> request<span class=\"token punctuation\">.</span>method <span class=\"token operator\">!==</span> <span class=\"token string\">'GET'</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>redisClient<span class=\"token punctuation\">.</span><span class=\"token function\">del</span><span class=\"token punctuation\">(</span><span class=\"token constant\">GROUPSTUDY_FULL_DATA</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n    <span class=\"token keyword\">return</span> next<span class=\"token punctuation\">.</span><span class=\"token function\">handle</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">pipe</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span>\n\n\n<span class=\"token decorator\"><span class=\"token at operator\">@</span><span class=\"token function\">UseInterceptors</span></span><span class=\"token punctuation\">(</span>GroupStudyInterceptor<span class=\"token punctuation\">)</span>\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">GroupStudyController</span> <span class=\"token punctuation\">{</span>\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>이렇게 Interceptor를 적용해두면, groupstudy 데이터가 변경되면 캐싱된 데이터가 사라집니다.</p>\n<h1>결과를 확인해보자</h1>\n<p>아래는 캐싱 적용전 /groupStudy/snapshot으로 들어오는 요청의 처리시간입니다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 66%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABT0lEQVR42pWT206DQBRF+/9vJmo1KjYxvvbJxGv6BX5JWxgY5sJc4LhnoBUK2kAyIenMXqx9Cos851QUnOq6oXA1ze8KvxljqaoMOecn9hryfphbhMNZlpMQinRVkbUOG+2ucy4+rCwFwqYL1vFuraDtdo3sGg/87oA1gDiodUVCSgRltAnAsLz3EdqCmm7VMex8SXmRUJpeI/fanfEtUClNEkAhZDTpA621PVgP6ADMH2F4i9xnDwgjKVWE8bIcGQYgTQI5YHe0318ODcPQtYahUrMMPSoXxTNlbAWhzdBQBVicoRgBTQDSdGXGHroZvg0NVWc3b4aozO4BvBoDY2V5qGxnVH6KllJ+9YFnKpu/DRlbwvACIi8nlY+GgqpZrw3+lGyF3ObUUP87Q6KpyuGTTQBcQuZ9+GIf5ldOAKcqhytUTtOEdrsb4vzjCPwBkLXxW7ZJqgsAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"20250318124533\"\n        title=\"\"\n        src=\"/static/b65a2fee19dbb09a06b88cef15de72b4/5a190/20250318124533.png\"\n        srcset=\"/static/b65a2fee19dbb09a06b88cef15de72b4/772e8/20250318124533.png 200w,\n/static/b65a2fee19dbb09a06b88cef15de72b4/e17e5/20250318124533.png 400w,\n/static/b65a2fee19dbb09a06b88cef15de72b4/5a190/20250318124533.png 800w,\n/static/b65a2fee19dbb09a06b88cef15de72b4/c1b63/20250318124533.png 1200w,\n/static/b65a2fee19dbb09a06b88cef15de72b4/ccd6a/20250318124533.png 1549w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n평균을 구해보면 225.2초입니다.</p>\n<p>아래는 캐싱 적용 후 요청의 처리시간입니다.\n<span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 67%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABbUlEQVR42pWTy07DMBBF+/Ns2NBNEQKJCoQAIcGCBRJiCf/AP/TpJLZjx3aGO06axiGiJZJVNbFPzp2ZTITIaLsV5L2nuq6TFUIgYwzpsqSqcr+elaUlG+9Td39ijCUhBCldkrGWnNsf5JfkeUFSKrJ4xlddh/jrnKH1+gtnP/HS7xYaAMRGhhVSUlEUVMKIOmCI0Aa0swvxsPcKyWa0Wp1Slj22ezxNrK1iJKU1aSw2qXtA54al2AE1QE8wvEGCj84+ApXSMRYbcgkOAZvIbHiB2Gcoy/PAEGZSqbhSQ5/UdGgoxB2gVxB5Sw37wNTwb2CWjQAZEOOiKdxRjQYdAvLFTdlsLmm5nAL8MtKUto7DpgznLzV8gOEc5977kS3prikyDvJxkRVqOEdTzpHstW9oo10BYA7gMU3Zd/maVuvZEFjhE2rmkMH8/39zeJvOIUeU3BDMYJbnsZ59Q64hto4YSsSd0mJxAuh9Z/gDuErxKpOEV+0AAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"20250318124603\"\n        title=\"\"\n        src=\"/static/c41b2d894e697dd8e50140bf9804e1e5/5a190/20250318124603.png\"\n        srcset=\"/static/c41b2d894e697dd8e50140bf9804e1e5/772e8/20250318124603.png 200w,\n/static/c41b2d894e697dd8e50140bf9804e1e5/e17e5/20250318124603.png 400w,\n/static/c41b2d894e697dd8e50140bf9804e1e5/5a190/20250318124603.png 800w,\n/static/c41b2d894e697dd8e50140bf9804e1e5/c1b63/20250318124603.png 1200w,\n/static/c41b2d894e697dd8e50140bf9804e1e5/280a1/20250318124603.png 1545w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span>\n평균을 구해보면 104.9입니다.</p>\n<p>처리시간을 2배이상 줄일 수 있었습니다.\n단순히 봐도 처리시간이 확연히 준 것을 알 수 있습니다.</p>\n<h1>앞으로는?</h1>\n<p>제가 사용중인 Redis 서버는 Ram 1GB 인스턴스에서 작동하고 있습니다.\n그래서 많은 데이터를 캐싱하기에는 좋지 않습니다.\n앞으로 같은 방법으로 duration 분석을 통해, 시간이 오래 걸리는 요청을 찾아내고, 그 부분을 캐싱하는 방식으로 활용해보려 합니다.</p>","frontmatter":{"date":"March 16, 2025","title":"시간이 오래걸리는 API를 캐싱하자"},"tableOfContents":"<ul>\n<li><a href=\"#%EC%8B%9C%EA%B0%84%EC%9D%B4-%EC%98%A4%EB%9E%98%EA%B1%B8%EB%A6%AC%EB%8A%94-api%EB%A5%BC-%EC%B0%BE%EC%95%84%EB%82%B4%EB%B3%B4%EC%9E%90\">시간이 오래걸리는 API를 찾아내보자</a></li>\n<li><a href=\"#%EC%9D%B4-%EB%A1%9C%EA%B7%B8%EB%A5%BC-kibana%EC%97%90%EC%84%9C-%EC%96%B4%EB%96%BB%EA%B2%8C-%EC%8B%9C%EA%B0%81%ED%99%94%ED%95%A0-%EC%88%98-%EC%9E%88%EC%9D%84%EA%B9%8C%EC%9A%94\">이 로그를 Kibana에서 어떻게 시각화할 수 있을까요?</a></li>\n<li><a href=\"#redis-%EC%BA%90%EC%8B%B1%EC%9D%84-%EC%A0%81%EC%9A%A9%ED%95%B4%EB%B3%B4%EC%9E%90\">Redis 캐싱을 적용해보자.</a></li>\n<li><a href=\"#%EC%9D%B4%EC%A0%9C-api-%EC%9A%94%EC%B2%AD%EC%9D%B4-%EB%B9%A8%EB%9D%BC%EC%A1%8C%EC%9D%84%EA%B9%8C\">이제 API 요청이 빨라졌을까?</a></li>\n<li><a href=\"#%EB%8D%B0%EC%9D%B4%ED%84%B0%EB%A5%BC-%EC%95%95%EC%B6%95%ED%95%98%EC%97%AC-%EB%8B%A4%EC%8B%9C-%EC%BA%90%EC%8B%B1%ED%95%B4%EB%B3%B4%EC%9E%90\">데이터를 압축하여 다시 캐싱해보자</a></li>\n<li><a href=\"#%EC%BA%90%EC%8B%B1%EB%90%9C-%EB%8D%B0%EC%9D%B4%ED%84%B0%EC%97%90-%EC%B6%94%EA%B0%80%EC%A0%81%EC%9D%B8-%EC%B2%98%EB%A6%AC%EA%B0%80-%ED%95%84%EC%9A%94%ED%95%A9%EB%8B%88%EB%8B%A4\">캐싱된 데이터에 추가적인 처리가 필요합니다.</a></li>\n<li><a href=\"#%EA%B2%B0%EA%B3%BC%EB%A5%BC-%ED%99%95%EC%9D%B8%ED%95%B4%EB%B3%B4%EC%9E%90\">결과를 확인해보자</a></li>\n<li><a href=\"#%EC%95%9E%EC%9C%BC%EB%A1%9C%EB%8A%94\">앞으로는?</a></li>\n</ul>"}},"pageContext":{"id":"d62b5a1b-62bd-5782-ace0-3623a5ef667e","frontmatter__slug":"/blog/about/caching","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["2018336255","2540505676","2678393935","2810064759","3398502926"],"slicesMap":{}}