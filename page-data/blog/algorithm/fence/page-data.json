{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/algorithm/fence/","result":{"data":{"markdownRemark":{"html":"<h1>문제</h1>\n<p><img src=\"../_resources/32ad52f56402638ed6732855f8efdcfb.png\" alt=\"32ad52f56402638ed6732855f8efdcfb.png\"></p>\n<h1>풀이</h1>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\n\nusing namespace std;\nint wood[20001];\n\n//start~end 판자로 만들 수 있는 최대 울타리 크기\nint divide(int start, int end) {\n\tif (start == end) return wood[start];\n\n\tint mid = (start + end) / 2;\n\n\tint leftMax = divide(start, mid);\n\tint rightMax = divide(mid + 1, end);\n\tint ret = max(leftMax, rightMax);\n\n\tint lo = mid; int hi = mid + 1;\n\tint height = min(wood[lo], wood[hi]);\n\n\tret = max(ret, 2 * (height));\n\n\twhile (lo &gt; start || hi &lt; end) {\n\t\tif (hi &lt; end &amp;&amp; (wood[lo - 1] &lt; wood[hi + 1] || lo == start)) {\n\t\t\thi++;\n\t\t\theight = min(height, wood[hi]);\n\t\t}\n\t\telse {\n\t\t\tlo--;\n\t\t\theight = min(height, wood[lo]);\n\t\t}\n\t\tret = max(ret, (hi - lo + 1) * height);\n\t}\n\n\treturn ret;\n}\n\nint main(void) {\n\tint N;\n\n\tcin &gt;&gt; N;\n\n\tfor (int i = 0; i &lt; N; i++) {\n\t\tcin &gt;&gt; wood[i];\n\t}\n\n\tcout &lt;&lt; divide(0, N - 1);\n\n\treturn 0;\n}</code></pre></div>\n<h1>아이디어</h1>\n<p>무식한 풀이로 가능한 모든 경우의 수를 계산해보면, (r - l + 1) * min(h[i])에 대해 가능한 r과 l을 2중 for문으로 돌아봐야하므로 시간복잡도가 O(n^2)이 되고, 최대 입력이 20000개 이므로 해결이 어렵다.\n따라서 분할 정복을 사용해 왼쪽 구간, 오른쪽 구간, 겹치는 구간을 계산해 최대값을 구하면 더 빠른 시간에 풀 수 있다.</p>\n<h1>복기</h1>\n<p>재귀를 통해 반으로 나누고 함수가 그 구간에서의 최대값을 반환하도록 하면, 재귀 호출의 결과로 왼쪽 구간 최대값, 오른쪽 구간 최대값을 얻을 수 있다.\n그리고 함수를 합치는 과정에서 중간에 있는 값을 구하면 된다. 함수를 합치는 과정을 무식하게 푸려다가 실패했는데, 책에서는 mid값과 mid + 1값에서 시작하여 좌우로 높이가 높은 사각형을 선택하며 범위를 넓히는 식으로 탐색했다.</p>\n<h1>시간복잡도</h1>\n<p>재귀 호출 외에 하는 일은 두 부분에 걸쳐있는 사각형을 찾는 작업이고, 이는 O(N)이다.\n문제를 항상 절반으로 나눠서 해결하므로 재귀 호출하는 부분은 O(logN)이 걸리고, 재귀호출마다 사각형을 찾으므로 결과적으로 시간복잡도는 O(NlogN)이 된다.</p>","frontmatter":{"date":"November 27, 2023","title":"[분할정복] 울타리 잘라내기"},"tableOfContents":"<ul>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C\">문제</a></li>\n<li><a href=\"#%ED%92%80%EC%9D%B4\">풀이</a></li>\n<li><a href=\"#%EC%95%84%EC%9D%B4%EB%94%94%EC%96%B4\">아이디어</a></li>\n<li><a href=\"#%EB%B3%B5%EA%B8%B0\">복기</a></li>\n<li><a href=\"#%EC%8B%9C%EA%B0%84%EB%B3%B5%EC%9E%A1%EB%8F%84\">시간복잡도</a></li>\n</ul>"}},"pageContext":{"id":"c9f7a457-11d8-502a-bf63-b94fbb5123f7","frontmatter__slug":"/blog/algorithm/fence","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["2018336255","2540505676","2678393935","2810064759","3398502926"],"slicesMap":{}}