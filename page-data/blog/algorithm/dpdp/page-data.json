{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/algorithm/dpdp/","result":{"data":{"markdownRemark":{"html":"<p>대게 동적 계획법을 사용하는 코드에서는 실제 답을 계산하는 과정을 별도로 구현한다.\n각 부분 문제마다 어떤 선택지를 택했을 때 최적해를 얻는지 기록해 두고, 별도의 재귀 함수를 통해 선택을 되짚어 가며 최적해를 생성해내면 된다.</p>\n<h1>코드</h1>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">int n;\nint box[101] = { 0, };\nint dp[101] = { 0, };\nint choices[101];\n\nint solve(int idx) {\n\tint&amp; ret = dp[idx];\n\tif (ret != -1)\n\t\treturn ret;\n\n\tret = 1;\n\n\tif (idx == n) return ret;\n\n\tint bestNext = -1;\n\n\tfor (int next = idx + 1; next &lt; n; next++) {\n\t\tif (box[idx] &lt; box[next]) {\n\t\t\tint cand = solve(next) + 1;\n\t\t\tif (cand &gt; ret) {\n\t\t\t\tret = cand;\n\t\t\t\tbestNext = next;\n\t\t\t}\n\t\t}\n\t}\n\tchoices[idx + 1] = bestNext;\n\treturn ret;\n}\n\nvoid reconstruct(int start, vector&lt;int&gt; &amp; seq) {\n\tif (start != -1) seq.push_back(box[start]);\n\tint next = choices[start + 1];\n\tif (next != -1) reconstruct(next, seq);\n}</code></pre></div>\n<h1>방법</h1>\n<ol>\n<li>재귀 호출의 각 단계에서 최적해를 만들었던 선택을 별도의 배열에 저장해 둔다.</li>\n<li>별도의 재귀 함수를 이용해 이 선택을 따라가며 각 선택지를 저장하거나 출력한다.</li>\n</ol>","frontmatter":{"date":"December 03, 2023","title":"[동적계획] 실제 해 구하기"},"tableOfContents":"<ul>\n<li><a href=\"#%EC%BD%94%EB%93%9C\">코드</a></li>\n<li><a href=\"#%EB%B0%A9%EB%B2%95\">방법</a></li>\n</ul>"}},"pageContext":{"id":"dd674f46-d6e7-52ff-811f-731524cc027b","frontmatter__slug":"/blog/algorithm/dpdp","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["2018336255","2540505676","2678393935","2810064759","3398502926"],"slicesMap":{}}