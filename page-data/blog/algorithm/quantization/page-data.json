{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/algorithm/quantization/","result":{"data":{"markdownRemark":{"html":"<h1>문제</h1>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 800px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 108.99999999999999%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAWCAYAAADAQbwGAAAACXBIWXMAABYlAAAWJQFJUiTwAAACB0lEQVR42q2UjXLjIAyEef/XvObfSbCNHTtOouNbrDRp2rle75jZAUkgpJUgrDdrG04nu16vdrlcNAuXd1nzLD/tuT7rbrebhbqubb/fC8fjYZ6Pwm63k3w4FD2y60BVVXbYHzQjn8+ThaZprI7F6TFG4wJ0yFpnpLa1rute0KZkbbb1fW8pdTaOo4UeQ1sMOMDI5pid4zjlQ8jjeM4RnHWIGUzTZMMwyM4+Ug/b7dYWi4WtVit7e/tlm81Ga/SeVoxHzZ4aFMQ5G+TVem3L5dJOuRaByIA25IiaptY6KvUSNXaiRU+atWhIJZsMogYURhy2baOwCxdJN5XU+3w4ils4Kntbrfu+u59xKuQwpfbOFzfHXN1yKAlEic05fAQcetsAtQ03QCw3EJmQZY/yrstgH0Dfz6l+HKGqdrod77fbdZ4LfLj82NCf6eQQfuIMUqahqVyjYjTiSi0Vi83pYS4NXmmNTW3T5QMNnM295BUt/ZnXNQWDz1Y6ePMnJx4znjiktzA8pvZ92AtFoZsJPjkg/zQoGtrCi+GVR/Z2cWDzAgUe+zp3+pRD9igfo/068le9HEIoT8lfzE8B72QScMa79ep6Jf8W+CF9/Yc4JHU+BoBMsfxf/A4IRg5ZwCGEPxL9kfg/gf10i74vviuqRI/9C/Q56EOYXwg8/BRQRJQhzf/b/6rybyovpMx7h0XeAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"20231209224957\"\n        title=\"\"\n        src=\"/static/5a04f99ea9449994e12f2a552c4cbb11/5a190/20231209224957.png\"\n        srcset=\"/static/5a04f99ea9449994e12f2a552c4cbb11/772e8/20231209224957.png 200w,\n/static/5a04f99ea9449994e12f2a552c4cbb11/e17e5/20231209224957.png 400w,\n/static/5a04f99ea9449994e12f2a552c4cbb11/5a190/20231209224957.png 800w,\n/static/5a04f99ea9449994e12f2a552c4cbb11/48ca3/20231209224957.png 1084w\"\n        sizes=\"(max-width: 800px) 100vw, 800px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<h1>풀이</h1>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\n#include&lt;vector&gt;\n#include&lt;algorithm&gt;\n\nusing namespace std;\n\nconst int INF = 987654321;\n\nint n, m;\nvector&lt;int&gt; v;\nint dp[101][101];\n\nint minError(int start, int end){\n\tint minNum = v[start];\n\tint maxNum = v[end];\n\n\tint result = INF;\n\tfor (int num = minNum; num &lt;= maxNum; num++) {\n\t\tint calc = 0;\n\t\tfor (int i = start; i &lt;= end; i++) {\n\t\t\tcalc += (num - v[i]) * (num - v[i]);\n\t\t}\n\t\tresult = min(result, calc);\n\t}\n\treturn result;\n}\n\n//start이휴를 part개로 나눌때\nint solve(int start, int parts) {\n\tif (start == n) return 0;\n\tif (parts == 0) return INF;\n\n\tint &amp;ret = dp[start][parts];\n\tif (ret != -1) return ret;\n\n\tret = INF;\n\n\tfor (int partsSize = 1; start + partsSize &lt;= n; partsSize++) {\n\t\tret = min(ret, minError(start, start + partsSize - 1) + solve(start + partsSize, parts - 1));\n\t}\n\treturn ret;\n}\n\nint main(void) {\n\tmemset(dp, -1, sizeof(dp));\n\n\tcin &gt;&gt; n &gt;&gt; m;\n\tfor (int i = 0; i &lt; n; i++) {\n\t\tint a;\n\t\tcin &gt;&gt; a;\n\t\tv.push_back(a);\n\t}\n\n\tsort(v.begin(), v.end());\n\n\tcout &lt;&lt; solve(0, m);\n}</code></pre></div>\n<h1>복기</h1>\n<ul>\n<li>문제의 단순화\n이 문제를 곧이 곧대로 푸려면, 양자화 할 수 10개를 1000의 범위에서 골라야 하므로 1000C10 이라는 엄청 큰 수의 계산을 해야 하므로 문제를 풀 수 없다.\n그래서 다음과 같은 아이디어가 필요하다.\n\"주어진 수열을 정렬하면, 같은 숫자로 양자화 되는 숫자들은 항상 인접해있다.\"\n주어진 수열을 정렬하면, 인접한 숫자들은 같은 수로 양자화 되기 때문에, 수열을 m등분 하는 것으로 문제를 단순화 할 수 있다.\n따라서 solve함수를 solve(start, parts): start인덱스에서부터 parts개로 양자화 했을 때, 최소 오차를 반환. 과 같이 정의하면 문제를 쉽게 풀 수 있다.</li>\n</ul>","frontmatter":{"date":"December 05, 2023","title":"[동적계획] 와일드카드"},"tableOfContents":"<ul>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C\">문제</a></li>\n<li><a href=\"#%ED%92%80%EC%9D%B4\">풀이</a></li>\n<li><a href=\"#%EB%B3%B5%EA%B8%B0\">복기</a></li>\n</ul>"}},"pageContext":{"id":"554def23-f385-5da9-b2bc-728552755224","frontmatter__slug":"/blog/algorithm/quantization","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["2018336255","2540505676","2678393935","2810064759","3398502926"],"slicesMap":{}}