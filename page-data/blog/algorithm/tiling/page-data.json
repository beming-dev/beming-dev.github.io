{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-tsx","path":"/blog/algorithm/tiling/","result":{"data":{"markdownRemark":{"html":"<h1>코드</h1>\n<div class=\"gatsby-highlight\" data-language=\"c++\"><pre class=\"language-c++\"><code class=\"language-c++\">#include&lt;iostream&gt;\n\nusing namespace std;\n\nint n; // max 100\nlong long dp[101] = {0,};\nconst int MOD = 1000000007;\n\nint main(void) {\n\tcin &gt;&gt; n;\n\n\tdp[0] = 1;\n\tdp[1] = 1;\n\tdp[2] = 2;\n\n\tfor (int i = 3; i &lt;= n; i++) {\n\t\tdp[i] = (dp[i - 1] + dp[i - 2]) % MOD;\n\t}\n\n\tif (n % 2 == 0) {\n\t\tcout &lt;&lt; ((dp[n] - dp[n / 2] + MOD) % MOD - dp[(n / 2) - 1] + MOD) % MOD;\n\t}\n\telse {\n\t\tcout &lt;&lt; dp[n] - dp[n / 2];\n\t}\n\n\treturn 0;\n}</code></pre></div>\n<h1>복기</h1>\n<p>처음에 n이 짝수인 경우 dp[n] - dp[n/2]만 하면 된다 생각했는데, 가운데가 ||인 경우와 =인 경우를 둘 다 생각해줘야 했다.\nMOD연산이 들어갈 때, 빼기가 들어가면 항상 MOD를 더하고  % 연산을 한번 더 해줘야 답이 제대로 나온다.</p>","frontmatter":{"date":"December 03, 2023","title":"[동적계획] 비대칭 타일링"},"tableOfContents":"<ul>\n<li><a href=\"#%EC%BD%94%EB%93%9C\">코드</a></li>\n<li><a href=\"#%EB%B3%B5%EA%B8%B0\">복기</a></li>\n</ul>"}},"pageContext":{"id":"1f8a4476-77f0-55d8-bc04-f6d7a3a0e345","frontmatter__slug":"/blog/algorithm/tiling","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":["2018336255","2540505676","2678393935","2810064759","3398502926"],"slicesMap":{}}